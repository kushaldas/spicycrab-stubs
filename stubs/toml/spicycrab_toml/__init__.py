"""Python stubs for the toml Rust crate.

Install with: cookcrab install toml
"""

from __future__ import annotations

from typing import Self

class SerializeDocumentTable:

    def serialize_key(self, input: T) -> None: ...

    def serialize_value(self, value: T) -> None: ...

    def end(self) -> Ok: ...

    def serialize_field(self, key: object, value: T) -> None: ...

    def end(self) -> Ok: ...

    def serialize_field(self, key: object, value: T) -> None: ...

    def end(self) -> Ok: ...

class SerializeDocumentTupleVariant:

    def serialize_field(self, value: T) -> None: ...

    def end(self) -> Ok: ...

class Serializer:
    """Serialization for TOML documents.

This structure implements serialization support for TOML to serialize an
arbitrary type to TOML. Note that the TOML format does not support all
datatypes in Rust, such as enums, tuples, and tuple structs. These types
will generate an error when serialized.

Currently a serializer always writes its output to an in-memory `String`,
which is passed in when creating the serializer itself.

To serialize TOML values, instead of documents, see
[`ValueSerializer`][super::value::ValueSerializer]."""

    @staticmethod
    def new(buf: object) -> "Serializer": ...

    @staticmethod
    def pretty(buf: object) -> "Serializer": ...

    def serialize_bool(self, _v: bool) -> Ok: ...

    def serialize_i8(self, _v: int) -> Ok: ...

    def serialize_i16(self, _v: int) -> Ok: ...

    def serialize_i32(self, _v: int) -> Ok: ...

    def serialize_i64(self, _v: int) -> Ok: ...

    def serialize_u8(self, _v: int) -> Ok: ...

    def serialize_u16(self, _v: int) -> Ok: ...

    def serialize_u32(self, _v: int) -> Ok: ...

    def serialize_u64(self, _v: int) -> Ok: ...

    def serialize_f32(self, _v: float) -> Ok: ...

    def serialize_f64(self, _v: float) -> Ok: ...

    def serialize_char(self, _v: str) -> Ok: ...

    def serialize_str(self, _v: str) -> Ok: ...

    def serialize_bytes(self, _v: object) -> Ok: ...

    def serialize_none(self) -> Ok: ...

    def serialize_some(self, v: T) -> Ok: ...

    def serialize_unit(self) -> Ok: ...

    def serialize_unit_struct(self, name: object) -> Ok: ...

    def serialize_unit_variant(self, name: object, _variant_index: int, _variant: object) -> Ok: ...

    def serialize_newtype_struct(self, _name: object, v: T) -> Ok: ...

    def serialize_newtype_variant(self, _name: object, _variant_index: int, variant: object, value: T) -> Ok: ...

    def serialize_seq(self, _len: int | None) -> SerializeSeq: ...

    def serialize_tuple(self, len: int) -> SerializeTuple: ...

    def serialize_tuple_struct(self, _name: object, len: int) -> SerializeTupleStruct: ...

    def serialize_tuple_variant(self, _name: object, _variant_index: int, variant: object, len: int) -> SerializeTupleVariant: ...

    def serialize_map(self, _len: int | None) -> SerializeMap: ...

    def serialize_struct(self, _name: object, len: int) -> SerializeStruct: ...

    def serialize_struct_variant(self, _name: object, _variant_index: int, variant: object, _len: int) -> SerializeStructVariant: ...

class Buffer:
    """TOML Document serialization buffer"""

    @staticmethod
    def new() -> "Buffer": ...

    def clear(self) -> None: ...

    def fmt(self, f: Formatter) -> Result: ...

class SerializeDatetime:

    def serialize_key(self, _input: T) -> None: ...

    def serialize_value(self, _value: T) -> None: ...

    def end(self) -> Ok: ...

    def serialize_field(self, key: object, value: T) -> None: ...

    def end(self) -> Ok: ...

class SerializeTable:

    def serialize_key(self, input: T) -> None: ...

    def serialize_value(self, value: T) -> None: ...

    def end(self) -> Ok: ...

    def serialize_field(self, key: object, value: T) -> None: ...

    def end(self) -> Ok: ...

class SerializeStructVariant:

    def serialize_field(self, key: object, value: T) -> None: ...

    def end(self) -> Ok: ...

class SerializeValueArray:

    def serialize_element(self, value: T) -> None: ...

    def end(self) -> Ok: ...

    def serialize_element(self, value: T) -> None: ...

    def end(self) -> Ok: ...

    def serialize_field(self, value: T) -> None: ...

    def end(self) -> Ok: ...

class SerializeTupleVariant:

    def serialize_field(self, value: T) -> None: ...

    def end(self) -> Ok: ...

class ValueSerializer:
    """Serialization for TOML [values][crate::Value].

This structure implements serialization support for TOML to serialize an
arbitrary type to TOML. Note that the TOML format does not support all
datatypes in Rust, such as enums, tuples, and tuple structs. These types
will generate an error when serialized.

Currently a serializer always writes its output to an in-memory `String`,
which is passed in when creating the serializer itself.

# Examples

```
use serde::Serialize;

#[derive(Serialize)]
struct Config {
database: Database,
}

#[derive(Serialize)]
struct Database {
ip: String,
port: Vec<u16>,
connection_max: u32,
enabled: bool,
}

let config = Config {
database: Database {
ip: "192.168.1.1".to_string(),
port: vec![8001, 8002, 8003],
connection_max: 5000,
enabled: false,
},
};

let mut value = String::new();
serde::Serialize::serialize(
&config,
toml::ser::ValueSerializer::new(&mut value)
).unwrap();
println!("{}", value)
```"""

    @staticmethod
    def new(dst: object) -> "ValueSerializer": ...

    def serialize_bool(self, v: bool) -> Ok: ...

    def serialize_i8(self, v: int) -> Ok: ...

    def serialize_i16(self, v: int) -> Ok: ...

    def serialize_i32(self, v: int) -> Ok: ...

    def serialize_i64(self, v: int) -> Ok: ...

    def serialize_i128(self, v: int) -> Ok: ...

    def serialize_u8(self, v: int) -> Ok: ...

    def serialize_u16(self, v: int) -> Ok: ...

    def serialize_u32(self, v: int) -> Ok: ...

    def serialize_u64(self, v: int) -> Ok: ...

    def serialize_u128(self, v: int) -> Ok: ...

    def serialize_f32(self, v: float) -> Ok: ...

    def serialize_f64(self, v: float) -> Ok: ...

    def serialize_char(self, v: str) -> Ok: ...

    def serialize_str(self, v: str) -> Ok: ...

    def serialize_bytes(self, value: object) -> Ok: ...

    def serialize_none(self) -> Ok: ...

    def serialize_some(self, value: T) -> Ok: ...

    def serialize_unit(self) -> Ok: ...

    def serialize_unit_struct(self, name: object) -> Ok: ...

    def serialize_unit_variant(self, _name: object, _variant_index: int, variant: object) -> Ok: ...

    def serialize_newtype_struct(self, _name: object, value: T) -> Ok: ...

    def serialize_newtype_variant(self, _name: object, _variant_index: int, variant: object, value: T) -> Ok: ...

    def serialize_seq(self, len: int | None) -> SerializeSeq: ...

    def serialize_tuple(self, len: int) -> SerializeTuple: ...

    def serialize_tuple_struct(self, _name: object, len: int) -> SerializeTupleStruct: ...

    def serialize_tuple_variant(self, _name: object, _variant_index: int, variant: object, len: int) -> SerializeTupleVariant: ...

    def serialize_map(self, _len: int | None) -> SerializeMap: ...

    def serialize_struct(self, name: object, _len: int) -> SerializeStruct: ...

    def serialize_struct_variant(self, _name: object, _variant_index: int, variant: object, len: int) -> SerializeStructVariant: ...

    def serialize_bool(self, value: bool) -> Value: ...

    def serialize_i8(self, value: int) -> Value: ...

    def serialize_i16(self, value: int) -> Value: ...

    def serialize_i32(self, value: int) -> Value: ...

    def serialize_i64(self, value: int) -> Value: ...

    def serialize_u8(self, value: int) -> Value: ...

    def serialize_u16(self, value: int) -> Value: ...

    def serialize_u32(self, value: int) -> Value: ...

    def serialize_u64(self, value: int) -> Value: ...

    def serialize_f32(self, value: float) -> Value: ...

    def serialize_f64(self, value: float) -> Value: ...

    def serialize_char(self, value: str) -> Value: ...

    def serialize_str(self, value: str) -> Value: ...

    def serialize_bytes(self, value: object) -> Value: ...

    def serialize_unit(self) -> Value: ...

    def serialize_unit_struct(self, name: object) -> Value: ...

    def serialize_unit_variant(self, _name: object, _variant_index: int, _variant: object) -> Value: ...

    def serialize_newtype_struct(self, _name: object, value: T) -> Value: ...

    def serialize_newtype_variant(self, _name: object, _variant_index: int, variant: object, value: T) -> Value: ...

    def serialize_none(self) -> Value: ...

    def serialize_some(self, value: T) -> Value: ...

    def serialize_seq(self, len: int | None) -> SerializeSeq: ...

    def serialize_tuple(self, len: int) -> SerializeTuple: ...

    def serialize_tuple_struct(self, _name: object, len: int) -> SerializeTupleStruct: ...

    def serialize_tuple_variant(self, _name: object, _variant_index: int, variant: object, len: int) -> SerializeTupleVariant: ...

    def serialize_map(self, _len: int | None) -> SerializeMap: ...

    def serialize_struct(self, _name: object, len: int) -> SerializeStruct: ...

    def serialize_struct_variant(self, _name: object, _variant_index: int, variant: object, len: int) -> SerializeStructVariant: ...

class Error:
    """Errors that can occur when serializing a type."""

    @staticmethod
    def from_(_: Exception) -> "Error": ...

    @staticmethod
    def custom(msg: T) -> "Error": ...

    def fmt(self, f: Formatter) -> Result: ...

    def fmt(self, f: Formatter) -> Result: ...

    def message(self) -> str: ...

    def span(self) -> object | None: ...

    def set_input(self, input: object) -> None: ...

    @staticmethod
    def custom(msg: T) -> "Error": ...

    def fmt(self, f: Formatter) -> Result: ...

class Map:
    """Represents a TOML key/value type."""

    @staticmethod
    def new() -> "Map": ...

    @staticmethod
    def with_capacity(capacity: int) -> "Map": ...

    @staticmethod
    def with_capacity(capacity: int) -> "Map": ...

    def clear(self) -> None: ...

    def get(self, key: Q) -> object: ...

    def contains_key(self, key: Q) -> bool: ...

    def get_mut(self, key: Q) -> object: ...

    def get_key_value(self, key: Q) -> object | None: ...

    def insert(self, k: K, v: V) -> V | None: ...

    def remove(self, key: Q) -> V | None: ...

    def remove_entry(self, key: Q) -> object | None: ...

    def retain(self, keep: F) -> None: ...

    def entry(self, key: S) -> object: ...

    def len(self) -> int: ...

    def is_empty(self) -> bool: ...

    def iter(self) -> object: ...

    def iter_mut(self) -> object: ...

    def keys(self) -> object: ...

    def values(self) -> object: ...

    @staticmethod
    def default() -> "Map": ...

    def clone(self) -> Self: ...

    def eq(self, other: Self) -> bool: ...

    def index(self, index: Q) -> V: ...

    def index_mut(self, index: Q) -> V: ...

    def fmt(self, formatter: Formatter) -> None: ...

    @staticmethod
    def from_iter(iter: T) -> "Map": ...

    def extend(self, iter: T) -> None: ...

    def into_iter(self) -> IntoIter: ...

class VacantEntry:
    """A vacant Entry. It is part of the [`Entry`] enum.

[`Entry`]: enum.Entry.html"""

    def key(self) -> K: ...

    def insert(self, value: V) -> object: ...

class OccupiedEntry:
    """An occupied Entry. It is part of the [`Entry`] enum.

[`Entry`]: enum.Entry.html"""

    def key(self) -> K: ...

    def get(self) -> V: ...

    def get_mut(self) -> V: ...

    def into_mut(self) -> object: ...

    def insert(self, value: V) -> V: ...

    def remove(self) -> V: ...

class Iter:
    """An iterator over a `toml::Map`'s entries."""
    pass

class IterMut:
    """A mutable iterator over a `toml::Map`'s entries."""
    pass

class IntoIter:
    """An owning iterator over a `toml::Map`'s entries."""
    pass

class Keys:
    """An iterator over a `toml::Map`'s keys."""
    pass

class Values:
    """An iterator over a `toml::Map`'s values."""
    pass

class ReadmeDoctests:
    pass

class ValueDeserializer:
    """Deserialization implementation for TOML [values][crate::Value].

# Example

```
# #[cfg(feature = "parse")] {
# #[cfg(feature = "display")] {
use serde::Deserialize;

#[derive(Deserialize)]
struct Config {
title: String,
owner: Owner,
}

#[derive(Deserialize)]
struct Owner {
name: String,
}

let value = r#"{ title = 'TOML Example', owner = { name = 'Lisa' } }"#;
let deserializer = toml::de::ValueDeserializer::parse(value).unwrap();
let config = Config::deserialize(deserializer).unwrap();
assert_eq!(config.title, "TOML Example");
assert_eq!(config.owner.name, "Lisa");
# }
# }
```"""

    @staticmethod
    def parse(raw: object) -> object: ...

    @staticmethod
    def new(raw: object) -> object: ...

    @staticmethod
    def from_(root: object) -> "ValueDeserializer": ...

    def deserialize_any(self, visitor: V) -> Value: ...

    def deserialize_u128(self, visitor: V) -> Value: ...

    def deserialize_i128(self, visitor: V) -> Value: ...

    def deserialize_option(self, visitor: V) -> Value: ...

    def deserialize_newtype_struct(self, _name: object, visitor: V) -> Value: ...

    def deserialize_struct(self, name: object, fields: object, visitor: V) -> Value: ...

    def deserialize_enum(self, name: object, variants: object, visitor: V) -> Value: ...

    def into_deserializer(self) -> Deserializer: ...

class Deserializer:
    """Deserialization for TOML [documents][crate::Table].

To deserializes TOML values, instead of documents, see [`ValueDeserializer`]."""

    @staticmethod
    def parse(raw: object) -> object: ...

    @staticmethod
    def new(raw: object) -> object: ...

    @staticmethod
    def from_(root: object) -> "Deserializer": ...

    def deserialize_any(self, visitor: V) -> Value: ...

    def deserialize_option(self, visitor: V) -> Value: ...

    def deserialize_newtype_struct(self, name: object, visitor: V) -> Value: ...

    def deserialize_struct(self, name: object, fields: object, visitor: V) -> Value: ...

    def deserialize_enum(self, name: object, variants: object, visitor: V) -> Value: ...

    def into_deserializer(self) -> Deserializer: ...

class DeInteger:
    """Represents a TOML integer"""

    def as_str(self) -> str: ...

    def radix(self) -> int: ...

    @staticmethod
    def default() -> "DeInteger": ...

    def fmt(self, formatter: Formatter) -> Result: ...

class DeFloat:
    """Represents a TOML integer"""

    def as_str(self) -> str: ...

    @staticmethod
    def default() -> "DeFloat": ...

    def fmt(self, formatter: Formatter) -> Result: ...

class DeArray:
    """Type representing a TOML array, payload of the `DeValue::Array` variant"""

    @staticmethod
    def new() -> "DeArray": ...

    def push(self, value: object) -> None: ...

    def deref(self) -> object: ...

    def deref_mut(self) -> object: ...

    def as_ref(self) -> object: ...

    def as_mut(self) -> object: ...

    def borrow(self) -> object: ...

    def borrow_mut(self) -> object: ...

    def index(self, index: I) -> Output: ...

    def into_iter(self) -> IntoIter: ...

    @staticmethod
    def from_iter(iter: I) -> "DeArray": ...

    @staticmethod
    def default() -> "DeArray": ...

    def fmt(self, formatter: Formatter) -> Result: ...

class Error:
    """Errors that can occur when deserializing a type."""

    @staticmethod
    def from_(_: Exception) -> "Error": ...

    @staticmethod
    def custom(msg: T) -> "Error": ...

    def fmt(self, f: Formatter) -> Result: ...

    def fmt(self, f: Formatter) -> Result: ...

    def message(self) -> str: ...

    def span(self) -> object | None: ...

    def set_input(self, input: object) -> None: ...

    @staticmethod
    def custom(msg: T) -> "Error": ...

    def fmt(self, f: Formatter) -> Result: ...

class SerializeMap:
    Datetime: "SerializeMap"
    Table: "SerializeMap"

    def serialize_key(self, input: T) -> None: ...

    def serialize_value(self, value: T) -> None: ...

    def end(self) -> Ok: ...

    def serialize_field(self, key: object, value: T) -> None: ...

    def end(self) -> Ok: ...

    def serialize_key(self, key: T) -> None: ...

    def serialize_value(self, value: T) -> None: ...

    def end(self) -> Table: ...

    def serialize_field(self, key: object, value: T) -> None: ...

    def end(self) -> Table: ...

class Entry:
    """A view into a single entry in a map, which may either be vacant or occupied.
This enum is constructed from the [`entry`] method on [`Map`].

[`entry`]: struct.Map.html#method.entry
[`Map`]: struct.Map.html"""
    Vacant: "Entry"
    Occupied: "Entry"

    def key(self) -> K: ...

    def or_insert(self, default: V) -> object: ...

    def or_insert_with(self, default: F) -> object: ...

class DeValue:
    """Representation of a TOML value."""
    String: "DeValue"
    Integer: "DeValue"
    Float: "DeValue"
    Boolean: "DeValue"
    Datetime: "DeValue"
    Array: "DeValue"
    Table: "DeValue"

    @staticmethod
    def parse(input: object) -> object: ...

    @staticmethod
    def parse_recoverable(input: object) -> object: ...

    def make_owned(self) -> None: ...

    def get(self, index: I) -> object: ...

    def as_integer(self) -> object: ...

    def is_integer(self) -> bool: ...

    def as_float(self) -> object: ...

    def is_float(self) -> bool: ...

    def as_bool(self) -> bool | None: ...

    def is_bool(self) -> bool: ...

    def as_str(self) -> object: ...

    def is_str(self) -> bool: ...

    def as_datetime(self) -> object: ...

    def is_datetime(self) -> bool: ...

    def as_array(self) -> object: ...

    def is_array(self) -> bool: ...

    def as_table(self) -> object: ...

    def is_table(self) -> bool: ...

    def same_type(self, other: DeValue) -> bool: ...

    def type_str(self) -> object: ...

    def index(self, index: I) -> object: ...

class Value:
    """Representation of a TOML value."""
    String: "Value"
    Integer: "Value"
    Float: "Value"
    Boolean: "Value"
    Datetime: "Value"
    Array: "Value"
    Table: "Value"

    @staticmethod
    def try_from(value: T) -> object: ...

    def try_into(self) -> T: ...

    def get(self, index: I) -> object: ...

    def get_mut(self, index: I) -> object: ...

    def as_integer(self) -> int | None: ...

    def is_integer(self) -> bool: ...

    def as_float(self) -> float | None: ...

    def is_float(self) -> bool: ...

    def as_bool(self) -> bool | None: ...

    def is_bool(self) -> bool: ...

    def as_str(self) -> object: ...

    def is_str(self) -> bool: ...

    def as_datetime(self) -> object: ...

    def is_datetime(self) -> bool: ...

    def as_array(self) -> object: ...

    def as_array_mut(self) -> object: ...

    def is_array(self) -> bool: ...

    def as_table(self) -> object: ...

    def as_table_mut(self) -> object: ...

    def is_table(self) -> bool: ...

    def same_type(self, other: Self) -> bool: ...

    def type_str(self) -> object: ...

    def index(self, index: I) -> Self: ...

    def index_mut(self, index: I) -> Self: ...

    @staticmethod
    def from_(val: object) -> "Value": ...

    @staticmethod
    def from_(val: list[V]) -> "Value": ...

    @staticmethod
    def from_(val: object) -> "Value": ...

    @staticmethod
    def from_(val: dict[S, V]) -> "Value": ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_str(s: str) -> object: ...

    def serialize(self, serializer: S) -> Ok: ...

    @staticmethod
    def deserialize(deserializer: D) -> object: ...

    def deserialize_any(self, visitor: V) -> Value: ...

    def deserialize_enum(self, _name: object, _variants: object, visitor: V) -> Value: ...

    def deserialize_option(self, visitor: V) -> Value: ...

    def deserialize_newtype_struct(self, _name: object, visitor: V) -> Value: ...

    def into_deserializer(self) -> Self: ...

"""Serialize the given data structure as a String of TOML.

Serialization can fail if `T`'s implementation of `Serialize` decides to
fail, if `T` contains a map with non-string keys, or if `T` attempts to
serialize an unsupported datatype such as an enum, tuple, or tuple struct.

To serialize TOML values, instead of documents, see [`ValueSerializer`].

# Examples

```
use serde::Serialize;

#[derive(Serialize)]
struct Config {
database: Database,
}

#[derive(Serialize)]
struct Database {
ip: String,
port: Vec<u16>,
connection_max: u32,
enabled: bool,
}

let config = Config {
database: Database {
ip: "192.168.1.1".to_string(),
port: vec![8001, 8002, 8003],
connection_max: 5000,
enabled: false,
},
};

let toml = toml::to_string(&config).unwrap();
println!("{}", toml)
```"""
def to_string(value: T) -> str: ...

"""Serialize the given data structure as a "pretty" String of TOML.

This is identical to `to_string` except the output string has a more
"pretty" output. See `Serializer::pretty` for more details.

To serialize TOML values, instead of documents, see [`ValueSerializer`].

For greater customization, instead serialize to a
[`toml_edit::DocumentMut`](https://docs.rs/toml_edit/latest/toml_edit/struct.DocumentMut.html)."""
def to_string_pretty(value: T) -> str: ...

"""Deserializes a string into a type.

This function will attempt to interpret `s` as a TOML document and
deserialize `T` from the document.

To deserializes TOML values, instead of documents, see [`ValueDeserializer`].

# Examples

```
use serde::Deserialize;

#[derive(Deserialize)]
struct Config {
title: String,
owner: Owner,
}

#[derive(Deserialize)]
struct Owner {
name: String,
}

let config: Config = toml::from_str(r#"
title = 'TOML Example'

[owner]
name = 'Lisa'
"#).unwrap();

assert_eq!(config.title, "TOML Example");
assert_eq!(config.owner.name, "Lisa");
```"""
def from_str(s: object) -> T: ...

"""Deserializes bytes into a type.

This function will attempt to interpret `s` as a TOML document and
deserialize `T` from the document.

To deserializes TOML values, instead of documents, see [`ValueDeserializer`]."""
def from_slice(s: object) -> T: ...

def insert_toml(root: Value, path: object, value: Value) -> None: ...

def push_toml(root: Value, path: object) -> None: ...

__all__: list[str] = ["to_string", "to_string_pretty", "from_str", "from_slice", "insert_toml", "push_toml", "SerializeDocumentTable", "SerializeDocumentTupleVariant", "Serializer", "Buffer", "SerializeDatetime", "SerializeTable", "SerializeStructVariant", "SerializeValueArray", "SerializeTupleVariant", "ValueSerializer", "Error", "Map", "VacantEntry", "OccupiedEntry", "Iter", "IterMut", "IntoIter", "Keys", "Values", "ReadmeDoctests", "ValueDeserializer", "Deserializer", "DeInteger", "DeFloat", "DeArray", "Error", "SerializeMap", "Entry", "DeValue", "Value"]
