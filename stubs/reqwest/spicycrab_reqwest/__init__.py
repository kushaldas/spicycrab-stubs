"""Python stubs for the reqwest Rust crate.

Install with: cookcrab install reqwest
"""

from __future__ import annotations

from typing import Self, TypeVar, Generic

T = TypeVar('T')
E = TypeVar('E')


class Result(Generic[T, E]):
    """A Result type alias for reqwest.

    Maps to reqwest::Result which is an alias for std::result::Result<T,Error>.
    """

    @staticmethod
    def Ok(value: T) -> "Result[T, E]":
        """Create a successful result."""
        ...

    @staticmethod
    def Err(error: E) -> "Result[T, E]":
        """Create an error result."""
        ...

class Builder:
    """Builder to configure retries

Construct with [`for_host()`]."""

    @staticmethod
    def scoped(scope: object) -> "Builder": ...

    def no_budget(self) -> Self: ...

    def max_extra_load(self, extra_percent: float) -> Self: ...

    def max_retries_per_request(self, max: int) -> Self: ...

    def classify_fn(self, func: F) -> Self: ...

    def classify(self, classifier: object) -> Self: ...

    def url(self, url: Url) -> Self: ...

class ScopeFn:

    def applies_to(self, req: Req) -> bool: ...

class ClassifyFn:

    def classify(self, req_rep: ReqRep) -> Action: ...

class ReqRep:

    def method(self) -> Method: ...

    def uri(self) -> Uri: ...

    def status(self) -> StatusCode | None: ...

    def error(self) -> object: ...

    def retryable(self) -> Action: ...

    def success(self) -> Action: ...

class Unnameable:
    pass

class Internal:
    pass

class Internal:
    pass

class Client:
    """An HTTP Client for WebAssembly.

Uses the browser's Fetch API to make requests. The `Client` holds
configuration that applies to all requests. To configure a `Client`,
use `Client::builder()`."""

    @staticmethod
    def new() -> "Client": ...

    @staticmethod
    def builder() -> ClientBuilder: ...

    def get(self, url: U) -> RequestBuilder: ...

    def post(self, url: U) -> RequestBuilder: ...

    def put(self, url: U) -> RequestBuilder: ...

    def patch(self, url: U) -> RequestBuilder: ...

    def delete(self, url: U) -> RequestBuilder: ...

    def head(self, url: U) -> RequestBuilder: ...

    def request(self, method: Method, url: U) -> RequestBuilder: ...

    def execute(self, request: Request) -> object: ...

    @staticmethod
    def default() -> "Client": ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Client": ...

    @staticmethod
    def new() -> "Client": ...

    @staticmethod
    def builder() -> ClientBuilder: ...

    def get(self, url: U) -> RequestBuilder: ...

    def post(self, url: U) -> RequestBuilder: ...

    def put(self, url: U) -> RequestBuilder: ...

    def patch(self, url: U) -> RequestBuilder: ...

    def delete(self, url: U) -> RequestBuilder: ...

    def head(self, url: U) -> RequestBuilder: ...

    def request(self, method: Method, url: U) -> RequestBuilder: ...

    def execute(self, request: Request) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    def poll_ready(self, _cx: Context) -> object: ...

    def call(self, req: Request) -> Future: ...

    @staticmethod
    def default() -> "Client": ...

    @staticmethod
    def new() -> "Client": ...

    @staticmethod
    def builder() -> ClientBuilder: ...

    def get(self, url: U) -> RequestBuilder: ...

    def post(self, url: U) -> RequestBuilder: ...

    def put(self, url: U) -> RequestBuilder: ...

    def patch(self, url: U) -> RequestBuilder: ...

    def delete(self, url: U) -> RequestBuilder: ...

    def head(self, url: U) -> RequestBuilder: ...

    def request(self, method: Method, url: U) -> RequestBuilder: ...

    def execute(self, request: Request) -> Response: ...

    def fmt(self, f: Formatter) -> Result: ...

class ClientBuilder:
    """A `ClientBuilder` can be used to create a `Client` with custom configuration."""

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def new() -> "ClientBuilder": ...

    def build(self) -> Client: ...

    def user_agent(self, value: V) -> ClientBuilder: ...

    def default_headers(self, headers: HeaderMap) -> ClientBuilder: ...

    @staticmethod
    def default() -> "ClientBuilder": ...

    @staticmethod
    def default() -> "ClientBuilder": ...

    @staticmethod
    def new() -> "ClientBuilder": ...

    def build(self) -> Client: ...

    def user_agent(self, value: V) -> ClientBuilder: ...

    def default_headers(self, headers: HeaderMap) -> ClientBuilder: ...

    def cookie_store(self, enable: bool) -> ClientBuilder: ...

    def cookie_provider(self, cookie_store: object) -> ClientBuilder: ...

    def gzip(self, enable: bool) -> ClientBuilder: ...

    def brotli(self, enable: bool) -> ClientBuilder: ...

    def zstd(self, enable: bool) -> ClientBuilder: ...

    def deflate(self, enable: bool) -> ClientBuilder: ...

    def no_gzip(self) -> ClientBuilder: ...

    def no_brotli(self) -> ClientBuilder: ...

    def no_zstd(self) -> ClientBuilder: ...

    def no_deflate(self) -> ClientBuilder: ...

    def redirect(self, policy: Policy) -> ClientBuilder: ...

    def referer(self, enable: bool) -> ClientBuilder: ...

    def retry(self, policy: Builder) -> ClientBuilder: ...

    def proxy(self, proxy: Proxy) -> ClientBuilder: ...

    def no_proxy(self) -> ClientBuilder: ...

    def timeout(self, timeout: Duration) -> ClientBuilder: ...

    def read_timeout(self, timeout: Duration) -> ClientBuilder: ...

    def connect_timeout(self, timeout: Duration) -> ClientBuilder: ...

    def connection_verbose(self, verbose: bool) -> ClientBuilder: ...

    def pool_idle_timeout(self, val: D) -> ClientBuilder: ...

    def pool_max_idle_per_host(self, max: int) -> ClientBuilder: ...

    def http1_title_case_headers(self) -> ClientBuilder: ...

    def http1_allow_obsolete_multiline_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_ignore_invalid_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_allow_spaces_after_header_name_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_only(self) -> ClientBuilder: ...

    def http09_responses(self) -> ClientBuilder: ...

    def http2_prior_knowledge(self) -> ClientBuilder: ...

    def http3_prior_knowledge(self) -> ClientBuilder: ...

    def http2_initial_stream_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_initial_connection_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_adaptive_window(self, enabled: bool) -> ClientBuilder: ...

    def http2_max_frame_size(self, sz: object) -> ClientBuilder: ...

    def http2_max_header_list_size(self, max_header_size_bytes: int) -> ClientBuilder: ...

    def http2_keep_alive_interval(self, interval: object) -> ClientBuilder: ...

    def http2_keep_alive_timeout(self, timeout: Duration) -> ClientBuilder: ...

    def http2_keep_alive_while_idle(self, enabled: bool) -> ClientBuilder: ...

    def tcp_nodelay(self, enabled: bool) -> ClientBuilder: ...

    def local_address(self, addr: T) -> ClientBuilder: ...

    def interface(self, interface: str) -> ClientBuilder: ...

    def tcp_keepalive(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_interval(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_retries(self, retries: C) -> ClientBuilder: ...

    def tcp_user_timeout(self, val: D) -> ClientBuilder: ...

    def unix_socket(self, path: object) -> ClientBuilder: ...

    def windows_named_pipe(self, pipe: object) -> ClientBuilder: ...

    def tls_certs_merge(self, certs: object) -> ClientBuilder: ...

    def tls_certs_only(self, certs: object) -> ClientBuilder: ...

    def add_root_certificate(self, cert: Certificate) -> ClientBuilder: ...

    def tls_crls_only(self, crls: object) -> ClientBuilder: ...

    def add_crl(self, crl: CertificateRevocationList) -> ClientBuilder: ...

    def add_crls(self, crls: object) -> ClientBuilder: ...

    def identity(self, identity: Identity) -> ClientBuilder: ...

    def tls_danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def tls_danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def tls_sni(self, tls_sni: bool) -> ClientBuilder: ...

    def tls_version_min(self, version: Version) -> ClientBuilder: ...

    def min_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_version_max(self, version: Version) -> ClientBuilder: ...

    def max_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_backend_native(self) -> ClientBuilder: ...

    def use_native_tls(self) -> ClientBuilder: ...

    def tls_backend_rustls(self) -> ClientBuilder: ...

    def use_rustls_tls(self) -> ClientBuilder: ...

    def tls_backend_preconfigured(self, tls: object) -> ClientBuilder: ...

    def use_preconfigured_tls(self, tls: object) -> ClientBuilder: ...

    def tls_info(self, tls_info: bool) -> ClientBuilder: ...

    def https_only(self, enabled: bool) -> ClientBuilder: ...

    def hickory_dns(self, enable: bool) -> ClientBuilder: ...

    def no_hickory_dns(self) -> ClientBuilder: ...

    def resolve(self, domain: str, addr: SocketAddr) -> ClientBuilder: ...

    def resolve_to_addrs(self, domain: str, addrs: object) -> ClientBuilder: ...

    def dns_resolver(self, resolver: R) -> ClientBuilder: ...

    def tls_early_data(self, enabled: bool) -> ClientBuilder: ...

    def http3_max_idle_timeout(self, value: Duration) -> ClientBuilder: ...

    def http3_stream_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_conn_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_send_window(self, value: int) -> ClientBuilder: ...

    def http3_congestion_bbr(self) -> ClientBuilder: ...

    def http3_max_field_section_size(self, value: int) -> ClientBuilder: ...

    def http3_send_grease(self, enabled: bool) -> ClientBuilder: ...

    def connector_layer(self, layer: L) -> ClientBuilder: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "ClientBuilder": ...

    @staticmethod
    def new() -> "ClientBuilder": ...

    def build(self) -> Client: ...

    def user_agent(self, value: V) -> ClientBuilder: ...

    def default_headers(self, headers: HeaderMap) -> ClientBuilder: ...

    def cookie_store(self, enable: bool) -> ClientBuilder: ...

    def cookie_provider(self, cookie_store: object) -> ClientBuilder: ...

    def gzip(self, enable: bool) -> ClientBuilder: ...

    def brotli(self, enable: bool) -> ClientBuilder: ...

    def zstd(self, enable: bool) -> ClientBuilder: ...

    def deflate(self, enable: bool) -> ClientBuilder: ...

    def no_gzip(self) -> ClientBuilder: ...

    def no_brotli(self) -> ClientBuilder: ...

    def no_zstd(self) -> ClientBuilder: ...

    def no_deflate(self) -> ClientBuilder: ...

    def redirect(self, policy: Policy) -> ClientBuilder: ...

    def retry(self, policy: Builder) -> ClientBuilder: ...

    def referer(self, enable: bool) -> ClientBuilder: ...

    def proxy(self, proxy: Proxy) -> ClientBuilder: ...

    def no_proxy(self) -> ClientBuilder: ...

    def timeout(self, timeout: T) -> ClientBuilder: ...

    def connect_timeout(self, timeout: T) -> ClientBuilder: ...

    def connection_verbose(self, verbose: bool) -> ClientBuilder: ...

    def pool_idle_timeout(self, val: D) -> ClientBuilder: ...

    def pool_max_idle_per_host(self, max: int) -> ClientBuilder: ...

    def http1_title_case_headers(self) -> ClientBuilder: ...

    def http1_allow_obsolete_multiline_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_ignore_invalid_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_allow_spaces_after_header_name_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_only(self) -> ClientBuilder: ...

    def http09_responses(self) -> ClientBuilder: ...

    def http2_prior_knowledge(self) -> ClientBuilder: ...

    def http2_initial_stream_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_initial_connection_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_adaptive_window(self, enabled: bool) -> ClientBuilder: ...

    def http2_max_frame_size(self, sz: object) -> ClientBuilder: ...

    def http2_max_header_list_size(self, max_header_size_bytes: int) -> ClientBuilder: ...

    def http3_prior_knowledge(self) -> ClientBuilder: ...

    def http3_max_idle_timeout(self, value: Duration) -> ClientBuilder: ...

    def http3_stream_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_conn_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_send_window(self, value: int) -> ClientBuilder: ...

    def http3_congestion_bbr(self) -> ClientBuilder: ...

    def http3_max_field_section_size(self, value: int) -> ClientBuilder: ...

    def http3_send_grease(self, enabled: bool) -> ClientBuilder: ...

    def tcp_nodelay(self, enabled: bool) -> ClientBuilder: ...

    def local_address(self, addr: T) -> ClientBuilder: ...

    def interface(self, interface: str) -> ClientBuilder: ...

    def tcp_keepalive(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_interval(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_retries(self, retries: C) -> ClientBuilder: ...

    def tcp_user_timeout(self, val: D) -> ClientBuilder: ...

    def unix_socket(self, path: object) -> ClientBuilder: ...

    def tls_certs_merge(self, certs: object) -> ClientBuilder: ...

    def tls_certs_only(self, certs: object) -> ClientBuilder: ...

    def add_root_certificate(self, cert: Certificate) -> ClientBuilder: ...

    def tls_crls_only(self, crls: object) -> ClientBuilder: ...

    def add_crl(self, crl: CertificateRevocationList) -> ClientBuilder: ...

    def add_crls(self, crls: object) -> ClientBuilder: ...

    def identity(self, identity: Identity) -> ClientBuilder: ...

    def tls_danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def tls_danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def tls_sni(self, tls_sni: bool) -> ClientBuilder: ...

    def tls_version_min(self, version: Version) -> ClientBuilder: ...

    def min_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_version_max(self, version: Version) -> ClientBuilder: ...

    def max_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_backend_native(self) -> ClientBuilder: ...

    def use_native_tls(self) -> ClientBuilder: ...

    def tls_backend_rustls(self) -> ClientBuilder: ...

    def use_rustls_tls(self) -> ClientBuilder: ...

    def tls_info(self, tls_info: bool) -> ClientBuilder: ...

    def tls_backend_preconfigured(self, tls: object) -> ClientBuilder: ...

    def use_preconfigured_tls(self, tls: object) -> ClientBuilder: ...

    def hickory_dns(self, enable: bool) -> ClientBuilder: ...

    def no_hickory_dns(self) -> ClientBuilder: ...

    def https_only(self, enabled: bool) -> ClientBuilder: ...

    def resolve(self, domain: str, addr: SocketAddr) -> ClientBuilder: ...

    def resolve_to_addrs(self, domain: str, addrs: object) -> ClientBuilder: ...

    def dns_resolver(self, resolver: object) -> ClientBuilder: ...

    def connector_layer(self, layer: L) -> ClientBuilder: ...

    @staticmethod
    def from_(builder: object) -> "ClientBuilder": ...

    def fmt(self, f: Formatter) -> Result: ...

class Body:
    """The body of a `Request`.

In most cases, this is not needed directly, as the
[`RequestBuilder.body`][builder] method uses `Into<Body>`, which allows
passing many things (like a string or vector of bytes).

[builder]: ./struct.RequestBuilder.html#method.body"""

    def as_bytes(self) -> object: ...

    @staticmethod
    def from_(bytes: Bytes) -> "Body": ...

    @staticmethod
    def from_(vec: list[int]) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(s: str) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Body": ...

    def as_bytes(self) -> object: ...

    @staticmethod
    def wrap_stream(stream: S) -> "Body": ...

    @staticmethod
    def wrap(inner: B) -> "Body": ...

    @staticmethod
    def default() -> "Body": ...

    @staticmethod
    def from_(bytes: Bytes) -> "Body": ...

    @staticmethod
    def from_(vec: list[int]) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(s: str) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(file: File) -> "Body": ...

    def fmt(self, f: Formatter) -> Result: ...

    def poll_frame(self, cx: Context) -> object: ...

    def size_hint(self) -> SizeHint: ...

    def is_end_stream(self) -> bool: ...

    @staticmethod
    def from_(r: Response) -> "Body": ...

    @staticmethod
    def new(reader: R) -> "Body": ...

    @staticmethod
    def sized(reader: R, len: int) -> "Body": ...

    def as_bytes(self) -> object: ...

    def buffer(self) -> object: ...

    @staticmethod
    def from_(v: list[int]) -> "Body": ...

    @staticmethod
    def from_(s: str) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(f: File) -> "Body": ...

    @staticmethod
    def from_(b: Bytes) -> "Body": ...

class Request:
    """A request which can be executed with `Client::execute()`."""

    @staticmethod
    def new(method: Method, url: Url) -> "Request": ...

    def method(self) -> Method: ...

    def method_mut(self) -> Method: ...

    def url(self) -> Url: ...

    def url_mut(self) -> Url: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def body(self) -> object: ...

    def body_mut(self) -> Body | None: ...

    def timeout(self) -> object: ...

    def timeout_mut(self) -> Duration | None: ...

    def try_clone(self) -> Request | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def try_from(req: object) -> object: ...

    @staticmethod
    def new(method: Method, url: Url) -> "Request": ...

    def method(self) -> Method: ...

    def method_mut(self) -> Method: ...

    def url(self) -> Url: ...

    def url_mut(self) -> Url: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def body(self) -> object: ...

    def body_mut(self) -> Body | None: ...

    def timeout(self) -> object: ...

    def timeout_mut(self) -> Duration | None: ...

    def version(self) -> Version: ...

    def version_mut(self) -> Version: ...

    def try_clone(self) -> Request | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def try_from(req: object) -> object: ...

    @staticmethod
    def new(method: Method, url: Url) -> "Request": ...

    def method(self) -> Method: ...

    def method_mut(self) -> Method: ...

    def url(self) -> Url: ...

    def url_mut(self) -> Url: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def version(self) -> Version: ...

    def version_mut(self) -> Version: ...

    def body(self) -> object: ...

    def body_mut(self) -> Body | None: ...

    def timeout(self) -> object: ...

    def timeout_mut(self) -> Duration | None: ...

    def try_clone(self) -> Request | None: ...

    @staticmethod
    def try_from(req: object) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

class RequestBuilder:
    """A builder to construct the properties of a `Request`."""

    @staticmethod
    def from_parts(client: Client, request: Request) -> "RequestBuilder": ...

    def query(self, query: T) -> RequestBuilder: ...

    def form(self, form: T) -> RequestBuilder: ...

    def json(self, json: T) -> RequestBuilder: ...

    def basic_auth(self, username: U, password: P | None) -> RequestBuilder: ...

    def bearer_auth(self, token: T) -> RequestBuilder: ...

    def body(self, body: T) -> RequestBuilder: ...

    def timeout(self, timeout: Duration) -> RequestBuilder: ...

    def multipart(self, multipart: Form) -> RequestBuilder: ...

    def header(self, key: K, value: V) -> RequestBuilder: ...

    def headers(self, headers: HeaderMap) -> RequestBuilder: ...

    def fetch_mode_no_cors(self) -> RequestBuilder: ...

    def fetch_credentials_same_origin(self) -> RequestBuilder: ...

    def fetch_credentials_include(self) -> RequestBuilder: ...

    def fetch_credentials_omit(self) -> RequestBuilder: ...

    def fetch_cache_default(self) -> RequestBuilder: ...

    def fetch_cache_no_store(self) -> RequestBuilder: ...

    def fetch_cache_reload(self) -> RequestBuilder: ...

    def fetch_cache_no_cache(self) -> RequestBuilder: ...

    def fetch_cache_force_cache(self) -> RequestBuilder: ...

    def fetch_cache_only_if_cached(self) -> RequestBuilder: ...

    def build(self) -> Request: ...

    def build_split(self) -> object: ...

    def send(self) -> Response: ...

    def try_clone(self) -> RequestBuilder | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_parts(client: Client, request: Request) -> "RequestBuilder": ...

    def header(self, key: K, value: V) -> RequestBuilder: ...

    def headers(self, headers: HeaderMap) -> RequestBuilder: ...

    def basic_auth(self, username: U, password: P | None) -> RequestBuilder: ...

    def bearer_auth(self, token: T) -> RequestBuilder: ...

    def body(self, body: T) -> RequestBuilder: ...

    def timeout(self, timeout: Duration) -> RequestBuilder: ...

    def multipart(self, multipart: Form) -> RequestBuilder: ...

    def query(self, query: T) -> RequestBuilder: ...

    def version(self, version: Version) -> RequestBuilder: ...

    def form(self, form: T) -> RequestBuilder: ...

    def json(self, json: T) -> RequestBuilder: ...

    def build(self) -> Request: ...

    def build_split(self) -> object: ...

    def send(self) -> object: ...

    def try_clone(self) -> RequestBuilder | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_parts(client: Client, request: Request) -> "RequestBuilder": ...

    def header(self, key: K, value: V) -> RequestBuilder: ...

    def headers(self, headers: HeaderMap) -> RequestBuilder: ...

    def basic_auth(self, username: U, password: P | None) -> RequestBuilder: ...

    def bearer_auth(self, token: T) -> RequestBuilder: ...

    def body(self, body: T) -> RequestBuilder: ...

    def timeout(self, timeout: Duration) -> RequestBuilder: ...

    def query(self, query: T) -> RequestBuilder: ...

    def version(self, version: Version) -> RequestBuilder: ...

    def form(self, form: T) -> RequestBuilder: ...

    def json(self, json: T) -> RequestBuilder: ...

    def multipart(self, multipart: Form) -> RequestBuilder: ...

    def build(self) -> Request: ...

    def build_split(self) -> object: ...

    def send(self) -> Response: ...

    def try_clone(self) -> RequestBuilder | None: ...

class Response:
    """A Response to a submitted `Request`."""

    def status(self) -> StatusCode: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def content_length(self) -> int | None: ...

    def url(self) -> Url: ...

    def json(self) -> T: ...

    def text(self) -> str: ...

    def bytes(self) -> Bytes: ...

    def bytes_stream(self) -> object: ...

    def error_for_status(self) -> object: ...

    def error_for_status_ref(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    def upgrade(self) -> Upgraded: ...

    def status(self) -> StatusCode: ...

    def version(self) -> Version: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def content_length(self) -> int | None: ...

    def cookies(self) -> object: ...

    def url(self) -> Url: ...

    def remote_addr(self) -> SocketAddr | None: ...

    def extensions(self) -> Extensions: ...

    def extensions_mut(self) -> Extensions: ...

    def text(self) -> str: ...

    def text_with_charset(self, default_encoding: str) -> str: ...

    def json(self) -> T: ...

    def bytes(self) -> Bytes: ...

    def chunk(self) -> Bytes | None: ...

    def bytes_stream(self) -> object: ...

    def error_for_status(self) -> object: ...

    def error_for_status_ref(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_(r: object) -> "Response": ...

    @staticmethod
    def from_(r: Response) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    def status(self) -> StatusCode: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def cookies(self) -> object: ...

    def version(self) -> Version: ...

    def url(self) -> Url: ...

    def remote_addr(self) -> SocketAddr | None: ...

    def extensions(self) -> Extensions: ...

    def extensions_mut(self) -> Extensions: ...

    def content_length(self) -> int | None: ...

    def json(self) -> T: ...

    def bytes(self) -> Bytes: ...

    def text(self) -> str: ...

    def text_with_charset(self, default_encoding: str) -> str: ...

    def copy_to(self, w: W) -> int: ...

    def error_for_status(self) -> object: ...

    def error_for_status_ref(self) -> object: ...

    def read(self, buf: object) -> int: ...

    @staticmethod
    def from_(r: object) -> "Response": ...

class Form:
    """An async multipart/form-data request."""

    @staticmethod
    def default() -> "Form": ...

    @staticmethod
    def new() -> "Form": ...

    def text(self, name: T, value: U) -> Form: ...

    def part(self, name: T, part: Part) -> Form: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Form": ...

    @staticmethod
    def new() -> "Form": ...

    def boundary(self) -> str: ...

    def text(self, name: T, value: U) -> Form: ...

    def file(self, name: T, path: U) -> Form: ...

    def part(self, name: T, part: Part) -> Form: ...

    def percent_encode_path_segment(self) -> Form: ...

    def percent_encode_attr_chars(self) -> Form: ...

    def percent_encode_noop(self) -> Form: ...

    def into_stream(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Form": ...

    @staticmethod
    def new() -> "Form": ...

    def boundary(self) -> str: ...

    def text(self, name: T, value: U) -> Form: ...

    def file(self, name: T, path: U) -> Form: ...

    def part(self, name: T, part: Part) -> Form: ...

    def percent_encode_path_segment(self) -> Form: ...

    def percent_encode_attr_chars(self) -> Form: ...

    def percent_encode_noop(self) -> Form: ...

    def into_reader(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

class Part:
    """A field in a multipart form."""

    @staticmethod
    def text(value: T) -> "Part": ...

    @staticmethod
    def bytes(value: T) -> "Part": ...

    @staticmethod
    def stream(value: T) -> "Part": ...

    def mime_str(self, mime: str) -> Part: ...

    def file_name(self, filename: T) -> Part: ...

    def headers(self, headers: HeaderMap) -> Part: ...

    def fmt(self, f: Formatter) -> Result: ...

    def metadata(self) -> PartMetadata: ...

    @staticmethod
    def text(value: T) -> "Part": ...

    @staticmethod
    def bytes(value: T) -> "Part": ...

    @staticmethod
    def stream(value: T) -> "Part": ...

    @staticmethod
    def stream_with_length(value: T, length: int) -> "Part": ...

    @staticmethod
    def file(path: T) -> "Part": ...

    def mime_str(self, mime: str) -> Part: ...

    def file_name(self, filename: T) -> Part: ...

    def headers(self, headers: HeaderMap) -> Part: ...

    def fmt(self, f: Formatter) -> Result: ...

    def value_len(self) -> int | None: ...

    def metadata(self) -> PartMetadata: ...

    @staticmethod
    def text(value: T) -> "Part": ...

    @staticmethod
    def bytes(value: T) -> "Part": ...

    @staticmethod
    def reader(value: T) -> "Part": ...

    @staticmethod
    def reader_with_length(value: T, length: int) -> "Part": ...

    @staticmethod
    def file(path: T) -> "Part": ...

    def mime_str(self, mime: str) -> Part: ...

    def file_name(self, filename: T) -> Part: ...

    def headers(self, headers: HeaderMap) -> Part: ...

    def fmt(self, f: Formatter) -> Result: ...

    def value_len(self) -> int | None: ...

    def metadata(self) -> PartMetadata: ...

class GaiResolver:

    @staticmethod
    def new() -> "GaiResolver": ...

    @staticmethod
    def default() -> "GaiResolver": ...

    def resolve(self, name: Name) -> Resolving: ...

class Name:
    """A name that must be resolved to addresses."""

    def as_str(self) -> str: ...

    @staticmethod
    def from_str(host: str) -> object: ...

class InvalidNameError:

    def fmt(self, f: Formatter) -> Result: ...

class Proxy:
    """Configuration of a proxy that a `Client` should pass requests to.

A `Proxy` has a couple pieces to it:

- a URL of how to talk to the proxy
- rules on what `Client` requests should be directed to the proxy

For instance, let's look at `Proxy::http`:

```rust
# fn run() -> Result<(), Box<dyn std::error::Error>> {
let proxy = reqwest::Proxy::http("https://secure.example")?;
# Ok(())
# }
```

This proxy will intercept all HTTP requests, and make use of the proxy
at `https://secure.example`. A request to `http://hyper.rs` will talk
to your proxy. A request to `https://hyper.rs` will not.

Multiple `Proxy` rules can be configured for a `Client`. The `Client` will
check each `Proxy` in the order it was added. This could mean that a
`Proxy` added first with eager intercept rules, such as `Proxy::all`,
would prevent a `Proxy` later in the list from ever working, so take care.

By enabling the `"socks"` feature it is possible to use a socks proxy:
```rust
# fn run() -> Result<(), Box<dyn std::error::Error>> {
let proxy = reqwest::Proxy::http("socks5://192.168.1.1:9000")?;
# Ok(())
# }
```"""

    @staticmethod
    def http(proxy_scheme: U) -> "Proxy": ...

    @staticmethod
    def https(proxy_scheme: U) -> "Proxy": ...

    @staticmethod
    def all(proxy_scheme: U) -> "Proxy": ...

    @staticmethod
    def custom(fun: F) -> "Proxy": ...

    def basic_auth(self, username: str, password: str) -> Proxy: ...

    def custom_http_auth(self, header_value: HeaderValue) -> Proxy: ...

    def headers(self, headers: HeaderMap) -> Proxy: ...

    def no_proxy(self, no_proxy: NoProxy | None) -> Proxy: ...

    def fmt(self, f: Formatter) -> Result: ...

class NoProxy:
    """A configuration for filtering out requests that shouldn't be proxied"""

    @staticmethod
    def from_env() -> NoProxy | None: ...

    @staticmethod
    def from_string(no_proxy_list: str) -> object: ...

class Pool:

    @staticmethod
    def new(timeout: Duration | None) -> "Pool": ...

    def connecting(self, key: Key) -> Connecting: ...

    def try_pool(self, key: Key) -> PoolClient | None: ...

    def new_connection(self, lock: ConnectingLock, driver: object, tx: object) -> PoolClient: ...

class ConnectingLock:
    """A lock that ensures only one HTTP/3 connection is established per host at a
time. The lock is automatically released when dropped."""

    def drop(self) -> None: ...

class ConnectingWaiter:
    """A waiter that allows subscribers to receive updates when a new connection is
established or when the connection attempt fails. For example, when
connection lock is dropped due to an error."""

    def receive(self) -> PoolClient | None: ...

class PoolClient:

    @staticmethod
    def new(tx: object) -> "PoolClient": ...

    def send_request(self, req: object) -> object: ...

class PoolConnection:

    @staticmethod
    def new(client: PoolClient, close_rx: object) -> "PoolConnection": ...

    def pool(self) -> PoolClient: ...

    def is_invalid(self) -> bool: ...

class Client:
    """An asynchronous `Client` to make Requests with.

The Client has various configuration values to tweak, but the defaults
are set to what is usually the most commonly desired value. To configure a
`Client`, use `Client::builder()`.

The `Client` holds a connection pool internally to improve performance
by reusing connections and avoiding setup overhead, so it is advised that
you create one and **reuse** it.

You do **not** have to wrap the `Client` in an [`Rc`] or [`Arc`] to **reuse** it,
because it already uses an [`Arc`] internally.

# Connection Pooling

The connection pool can be configured using [`ClientBuilder`] methods
with the `pool_` prefix, such as [`ClientBuilder::pool_idle_timeout`]
and [`ClientBuilder::pool_max_idle_per_host`].

[`Rc`]: std::rc::Rc"""

    @staticmethod
    def new() -> "Client": ...

    @staticmethod
    def builder() -> ClientBuilder: ...

    def get(self, url: U) -> RequestBuilder: ...

    def post(self, url: U) -> RequestBuilder: ...

    def put(self, url: U) -> RequestBuilder: ...

    def patch(self, url: U) -> RequestBuilder: ...

    def delete(self, url: U) -> RequestBuilder: ...

    def head(self, url: U) -> RequestBuilder: ...

    def request(self, method: Method, url: U) -> RequestBuilder: ...

    def execute(self, request: Request) -> object: ...

    @staticmethod
    def default() -> "Client": ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Client": ...

    @staticmethod
    def new() -> "Client": ...

    @staticmethod
    def builder() -> ClientBuilder: ...

    def get(self, url: U) -> RequestBuilder: ...

    def post(self, url: U) -> RequestBuilder: ...

    def put(self, url: U) -> RequestBuilder: ...

    def patch(self, url: U) -> RequestBuilder: ...

    def delete(self, url: U) -> RequestBuilder: ...

    def head(self, url: U) -> RequestBuilder: ...

    def request(self, method: Method, url: U) -> RequestBuilder: ...

    def execute(self, request: Request) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    def poll_ready(self, _cx: Context) -> object: ...

    def call(self, req: Request) -> Future: ...

    @staticmethod
    def default() -> "Client": ...

    @staticmethod
    def new() -> "Client": ...

    @staticmethod
    def builder() -> ClientBuilder: ...

    def get(self, url: U) -> RequestBuilder: ...

    def post(self, url: U) -> RequestBuilder: ...

    def put(self, url: U) -> RequestBuilder: ...

    def patch(self, url: U) -> RequestBuilder: ...

    def delete(self, url: U) -> RequestBuilder: ...

    def head(self, url: U) -> RequestBuilder: ...

    def request(self, method: Method, url: U) -> RequestBuilder: ...

    def execute(self, request: Request) -> Response: ...

    def fmt(self, f: Formatter) -> Result: ...

class ClientBuilder:
    """A `ClientBuilder` can be used to create a `Client` with custom configuration."""

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def new() -> "ClientBuilder": ...

    def build(self) -> Client: ...

    def user_agent(self, value: V) -> ClientBuilder: ...

    def default_headers(self, headers: HeaderMap) -> ClientBuilder: ...

    @staticmethod
    def default() -> "ClientBuilder": ...

    @staticmethod
    def default() -> "ClientBuilder": ...

    @staticmethod
    def new() -> "ClientBuilder": ...

    def build(self) -> Client: ...

    def user_agent(self, value: V) -> ClientBuilder: ...

    def default_headers(self, headers: HeaderMap) -> ClientBuilder: ...

    def cookie_store(self, enable: bool) -> ClientBuilder: ...

    def cookie_provider(self, cookie_store: object) -> ClientBuilder: ...

    def gzip(self, enable: bool) -> ClientBuilder: ...

    def brotli(self, enable: bool) -> ClientBuilder: ...

    def zstd(self, enable: bool) -> ClientBuilder: ...

    def deflate(self, enable: bool) -> ClientBuilder: ...

    def no_gzip(self) -> ClientBuilder: ...

    def no_brotli(self) -> ClientBuilder: ...

    def no_zstd(self) -> ClientBuilder: ...

    def no_deflate(self) -> ClientBuilder: ...

    def redirect(self, policy: Policy) -> ClientBuilder: ...

    def referer(self, enable: bool) -> ClientBuilder: ...

    def retry(self, policy: Builder) -> ClientBuilder: ...

    def proxy(self, proxy: Proxy) -> ClientBuilder: ...

    def no_proxy(self) -> ClientBuilder: ...

    def timeout(self, timeout: Duration) -> ClientBuilder: ...

    def read_timeout(self, timeout: Duration) -> ClientBuilder: ...

    def connect_timeout(self, timeout: Duration) -> ClientBuilder: ...

    def connection_verbose(self, verbose: bool) -> ClientBuilder: ...

    def pool_idle_timeout(self, val: D) -> ClientBuilder: ...

    def pool_max_idle_per_host(self, max: int) -> ClientBuilder: ...

    def http1_title_case_headers(self) -> ClientBuilder: ...

    def http1_allow_obsolete_multiline_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_ignore_invalid_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_allow_spaces_after_header_name_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_only(self) -> ClientBuilder: ...

    def http09_responses(self) -> ClientBuilder: ...

    def http2_prior_knowledge(self) -> ClientBuilder: ...

    def http3_prior_knowledge(self) -> ClientBuilder: ...

    def http2_initial_stream_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_initial_connection_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_adaptive_window(self, enabled: bool) -> ClientBuilder: ...

    def http2_max_frame_size(self, sz: object) -> ClientBuilder: ...

    def http2_max_header_list_size(self, max_header_size_bytes: int) -> ClientBuilder: ...

    def http2_keep_alive_interval(self, interval: object) -> ClientBuilder: ...

    def http2_keep_alive_timeout(self, timeout: Duration) -> ClientBuilder: ...

    def http2_keep_alive_while_idle(self, enabled: bool) -> ClientBuilder: ...

    def tcp_nodelay(self, enabled: bool) -> ClientBuilder: ...

    def local_address(self, addr: T) -> ClientBuilder: ...

    def interface(self, interface: str) -> ClientBuilder: ...

    def tcp_keepalive(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_interval(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_retries(self, retries: C) -> ClientBuilder: ...

    def tcp_user_timeout(self, val: D) -> ClientBuilder: ...

    def unix_socket(self, path: object) -> ClientBuilder: ...

    def windows_named_pipe(self, pipe: object) -> ClientBuilder: ...

    def tls_certs_merge(self, certs: object) -> ClientBuilder: ...

    def tls_certs_only(self, certs: object) -> ClientBuilder: ...

    def add_root_certificate(self, cert: Certificate) -> ClientBuilder: ...

    def tls_crls_only(self, crls: object) -> ClientBuilder: ...

    def add_crl(self, crl: CertificateRevocationList) -> ClientBuilder: ...

    def add_crls(self, crls: object) -> ClientBuilder: ...

    def identity(self, identity: Identity) -> ClientBuilder: ...

    def tls_danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def tls_danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def tls_sni(self, tls_sni: bool) -> ClientBuilder: ...

    def tls_version_min(self, version: Version) -> ClientBuilder: ...

    def min_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_version_max(self, version: Version) -> ClientBuilder: ...

    def max_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_backend_native(self) -> ClientBuilder: ...

    def use_native_tls(self) -> ClientBuilder: ...

    def tls_backend_rustls(self) -> ClientBuilder: ...

    def use_rustls_tls(self) -> ClientBuilder: ...

    def tls_backend_preconfigured(self, tls: object) -> ClientBuilder: ...

    def use_preconfigured_tls(self, tls: object) -> ClientBuilder: ...

    def tls_info(self, tls_info: bool) -> ClientBuilder: ...

    def https_only(self, enabled: bool) -> ClientBuilder: ...

    def hickory_dns(self, enable: bool) -> ClientBuilder: ...

    def no_hickory_dns(self) -> ClientBuilder: ...

    def resolve(self, domain: str, addr: SocketAddr) -> ClientBuilder: ...

    def resolve_to_addrs(self, domain: str, addrs: object) -> ClientBuilder: ...

    def dns_resolver(self, resolver: R) -> ClientBuilder: ...

    def tls_early_data(self, enabled: bool) -> ClientBuilder: ...

    def http3_max_idle_timeout(self, value: Duration) -> ClientBuilder: ...

    def http3_stream_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_conn_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_send_window(self, value: int) -> ClientBuilder: ...

    def http3_congestion_bbr(self) -> ClientBuilder: ...

    def http3_max_field_section_size(self, value: int) -> ClientBuilder: ...

    def http3_send_grease(self, enabled: bool) -> ClientBuilder: ...

    def connector_layer(self, layer: L) -> ClientBuilder: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "ClientBuilder": ...

    @staticmethod
    def new() -> "ClientBuilder": ...

    def build(self) -> Client: ...

    def user_agent(self, value: V) -> ClientBuilder: ...

    def default_headers(self, headers: HeaderMap) -> ClientBuilder: ...

    def cookie_store(self, enable: bool) -> ClientBuilder: ...

    def cookie_provider(self, cookie_store: object) -> ClientBuilder: ...

    def gzip(self, enable: bool) -> ClientBuilder: ...

    def brotli(self, enable: bool) -> ClientBuilder: ...

    def zstd(self, enable: bool) -> ClientBuilder: ...

    def deflate(self, enable: bool) -> ClientBuilder: ...

    def no_gzip(self) -> ClientBuilder: ...

    def no_brotli(self) -> ClientBuilder: ...

    def no_zstd(self) -> ClientBuilder: ...

    def no_deflate(self) -> ClientBuilder: ...

    def redirect(self, policy: Policy) -> ClientBuilder: ...

    def retry(self, policy: Builder) -> ClientBuilder: ...

    def referer(self, enable: bool) -> ClientBuilder: ...

    def proxy(self, proxy: Proxy) -> ClientBuilder: ...

    def no_proxy(self) -> ClientBuilder: ...

    def timeout(self, timeout: T) -> ClientBuilder: ...

    def connect_timeout(self, timeout: T) -> ClientBuilder: ...

    def connection_verbose(self, verbose: bool) -> ClientBuilder: ...

    def pool_idle_timeout(self, val: D) -> ClientBuilder: ...

    def pool_max_idle_per_host(self, max: int) -> ClientBuilder: ...

    def http1_title_case_headers(self) -> ClientBuilder: ...

    def http1_allow_obsolete_multiline_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_ignore_invalid_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_allow_spaces_after_header_name_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_only(self) -> ClientBuilder: ...

    def http09_responses(self) -> ClientBuilder: ...

    def http2_prior_knowledge(self) -> ClientBuilder: ...

    def http2_initial_stream_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_initial_connection_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_adaptive_window(self, enabled: bool) -> ClientBuilder: ...

    def http2_max_frame_size(self, sz: object) -> ClientBuilder: ...

    def http2_max_header_list_size(self, max_header_size_bytes: int) -> ClientBuilder: ...

    def http3_prior_knowledge(self) -> ClientBuilder: ...

    def http3_max_idle_timeout(self, value: Duration) -> ClientBuilder: ...

    def http3_stream_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_conn_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_send_window(self, value: int) -> ClientBuilder: ...

    def http3_congestion_bbr(self) -> ClientBuilder: ...

    def http3_max_field_section_size(self, value: int) -> ClientBuilder: ...

    def http3_send_grease(self, enabled: bool) -> ClientBuilder: ...

    def tcp_nodelay(self, enabled: bool) -> ClientBuilder: ...

    def local_address(self, addr: T) -> ClientBuilder: ...

    def interface(self, interface: str) -> ClientBuilder: ...

    def tcp_keepalive(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_interval(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_retries(self, retries: C) -> ClientBuilder: ...

    def tcp_user_timeout(self, val: D) -> ClientBuilder: ...

    def unix_socket(self, path: object) -> ClientBuilder: ...

    def tls_certs_merge(self, certs: object) -> ClientBuilder: ...

    def tls_certs_only(self, certs: object) -> ClientBuilder: ...

    def add_root_certificate(self, cert: Certificate) -> ClientBuilder: ...

    def tls_crls_only(self, crls: object) -> ClientBuilder: ...

    def add_crl(self, crl: CertificateRevocationList) -> ClientBuilder: ...

    def add_crls(self, crls: object) -> ClientBuilder: ...

    def identity(self, identity: Identity) -> ClientBuilder: ...

    def tls_danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def tls_danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def tls_sni(self, tls_sni: bool) -> ClientBuilder: ...

    def tls_version_min(self, version: Version) -> ClientBuilder: ...

    def min_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_version_max(self, version: Version) -> ClientBuilder: ...

    def max_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_backend_native(self) -> ClientBuilder: ...

    def use_native_tls(self) -> ClientBuilder: ...

    def tls_backend_rustls(self) -> ClientBuilder: ...

    def use_rustls_tls(self) -> ClientBuilder: ...

    def tls_info(self, tls_info: bool) -> ClientBuilder: ...

    def tls_backend_preconfigured(self, tls: object) -> ClientBuilder: ...

    def use_preconfigured_tls(self, tls: object) -> ClientBuilder: ...

    def hickory_dns(self, enable: bool) -> ClientBuilder: ...

    def no_hickory_dns(self) -> ClientBuilder: ...

    def https_only(self, enabled: bool) -> ClientBuilder: ...

    def resolve(self, domain: str, addr: SocketAddr) -> ClientBuilder: ...

    def resolve_to_addrs(self, domain: str, addrs: object) -> ClientBuilder: ...

    def dns_resolver(self, resolver: object) -> ClientBuilder: ...

    def connector_layer(self, layer: L) -> ClientBuilder: ...

    @staticmethod
    def from_(builder: object) -> "ClientBuilder": ...

    def fmt(self, f: Formatter) -> Result: ...

class Body:
    """An asynchronous request body."""

    def as_bytes(self) -> object: ...

    @staticmethod
    def from_(bytes: Bytes) -> "Body": ...

    @staticmethod
    def from_(vec: list[int]) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(s: str) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Body": ...

    def as_bytes(self) -> object: ...

    @staticmethod
    def wrap_stream(stream: S) -> "Body": ...

    @staticmethod
    def wrap(inner: B) -> "Body": ...

    @staticmethod
    def default() -> "Body": ...

    @staticmethod
    def from_(bytes: Bytes) -> "Body": ...

    @staticmethod
    def from_(vec: list[int]) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(s: str) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(file: File) -> "Body": ...

    def fmt(self, f: Formatter) -> Result: ...

    def poll_frame(self, cx: Context) -> object: ...

    def size_hint(self) -> SizeHint: ...

    def is_end_stream(self) -> bool: ...

    @staticmethod
    def from_(r: Response) -> "Body": ...

    @staticmethod
    def new(reader: R) -> "Body": ...

    @staticmethod
    def sized(reader: R, len: int) -> "Body": ...

    def as_bytes(self) -> object: ...

    def buffer(self) -> object: ...

    @staticmethod
    def from_(v: list[int]) -> "Body": ...

    @staticmethod
    def from_(s: str) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(f: File) -> "Body": ...

    @staticmethod
    def from_(b: Bytes) -> "Body": ...

class Upgraded:
    """An upgraded HTTP connection."""

    def poll_read(self, cx: Context, buf: ReadBuf) -> object: ...

    def poll_write(self, cx: Context, buf: object) -> object: ...

    def poll_write_vectored(self, cx: Context, bufs: object) -> object: ...

    def poll_flush(self, cx: Context) -> object: ...

    def poll_shutdown(self, cx: Context) -> object: ...

    def is_write_vectored(self) -> bool: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_(inner: Upgraded) -> "Upgraded": ...

class Request:
    """A request which can be executed with `Client::execute()`."""

    @staticmethod
    def new(method: Method, url: Url) -> "Request": ...

    def method(self) -> Method: ...

    def method_mut(self) -> Method: ...

    def url(self) -> Url: ...

    def url_mut(self) -> Url: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def body(self) -> object: ...

    def body_mut(self) -> Body | None: ...

    def timeout(self) -> object: ...

    def timeout_mut(self) -> Duration | None: ...

    def try_clone(self) -> Request | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def try_from(req: object) -> object: ...

    @staticmethod
    def new(method: Method, url: Url) -> "Request": ...

    def method(self) -> Method: ...

    def method_mut(self) -> Method: ...

    def url(self) -> Url: ...

    def url_mut(self) -> Url: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def body(self) -> object: ...

    def body_mut(self) -> Body | None: ...

    def timeout(self) -> object: ...

    def timeout_mut(self) -> Duration | None: ...

    def version(self) -> Version: ...

    def version_mut(self) -> Version: ...

    def try_clone(self) -> Request | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def try_from(req: object) -> object: ...

    @staticmethod
    def new(method: Method, url: Url) -> "Request": ...

    def method(self) -> Method: ...

    def method_mut(self) -> Method: ...

    def url(self) -> Url: ...

    def url_mut(self) -> Url: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def version(self) -> Version: ...

    def version_mut(self) -> Version: ...

    def body(self) -> object: ...

    def body_mut(self) -> Body | None: ...

    def timeout(self) -> object: ...

    def timeout_mut(self) -> Duration | None: ...

    def try_clone(self) -> Request | None: ...

    @staticmethod
    def try_from(req: object) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

class RequestBuilder:
    """A builder to construct the properties of a `Request`.

To construct a `RequestBuilder`, refer to the `Client` documentation."""

    @staticmethod
    def from_parts(client: Client, request: Request) -> "RequestBuilder": ...

    def query(self, query: T) -> RequestBuilder: ...

    def form(self, form: T) -> RequestBuilder: ...

    def json(self, json: T) -> RequestBuilder: ...

    def basic_auth(self, username: U, password: P | None) -> RequestBuilder: ...

    def bearer_auth(self, token: T) -> RequestBuilder: ...

    def body(self, body: T) -> RequestBuilder: ...

    def timeout(self, timeout: Duration) -> RequestBuilder: ...

    def multipart(self, multipart: Form) -> RequestBuilder: ...

    def header(self, key: K, value: V) -> RequestBuilder: ...

    def headers(self, headers: HeaderMap) -> RequestBuilder: ...

    def fetch_mode_no_cors(self) -> RequestBuilder: ...

    def fetch_credentials_same_origin(self) -> RequestBuilder: ...

    def fetch_credentials_include(self) -> RequestBuilder: ...

    def fetch_credentials_omit(self) -> RequestBuilder: ...

    def fetch_cache_default(self) -> RequestBuilder: ...

    def fetch_cache_no_store(self) -> RequestBuilder: ...

    def fetch_cache_reload(self) -> RequestBuilder: ...

    def fetch_cache_no_cache(self) -> RequestBuilder: ...

    def fetch_cache_force_cache(self) -> RequestBuilder: ...

    def fetch_cache_only_if_cached(self) -> RequestBuilder: ...

    def build(self) -> Request: ...

    def build_split(self) -> object: ...

    def send(self) -> Response: ...

    def try_clone(self) -> RequestBuilder | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_parts(client: Client, request: Request) -> "RequestBuilder": ...

    def header(self, key: K, value: V) -> RequestBuilder: ...

    def headers(self, headers: HeaderMap) -> RequestBuilder: ...

    def basic_auth(self, username: U, password: P | None) -> RequestBuilder: ...

    def bearer_auth(self, token: T) -> RequestBuilder: ...

    def body(self, body: T) -> RequestBuilder: ...

    def timeout(self, timeout: Duration) -> RequestBuilder: ...

    def multipart(self, multipart: Form) -> RequestBuilder: ...

    def query(self, query: T) -> RequestBuilder: ...

    def version(self, version: Version) -> RequestBuilder: ...

    def form(self, form: T) -> RequestBuilder: ...

    def json(self, json: T) -> RequestBuilder: ...

    def build(self) -> Request: ...

    def build_split(self) -> object: ...

    def send(self) -> object: ...

    def try_clone(self) -> RequestBuilder | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_parts(client: Client, request: Request) -> "RequestBuilder": ...

    def header(self, key: K, value: V) -> RequestBuilder: ...

    def headers(self, headers: HeaderMap) -> RequestBuilder: ...

    def basic_auth(self, username: U, password: P | None) -> RequestBuilder: ...

    def bearer_auth(self, token: T) -> RequestBuilder: ...

    def body(self, body: T) -> RequestBuilder: ...

    def timeout(self, timeout: Duration) -> RequestBuilder: ...

    def query(self, query: T) -> RequestBuilder: ...

    def version(self, version: Version) -> RequestBuilder: ...

    def form(self, form: T) -> RequestBuilder: ...

    def json(self, json: T) -> RequestBuilder: ...

    def multipart(self, multipart: Form) -> RequestBuilder: ...

    def build(self) -> Request: ...

    def build_split(self) -> object: ...

    def send(self) -> Response: ...

    def try_clone(self) -> RequestBuilder | None: ...

class Response:
    """A Response to a submitted `Request`."""

    def status(self) -> StatusCode: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def content_length(self) -> int | None: ...

    def url(self) -> Url: ...

    def json(self) -> T: ...

    def text(self) -> str: ...

    def bytes(self) -> Bytes: ...

    def bytes_stream(self) -> object: ...

    def error_for_status(self) -> object: ...

    def error_for_status_ref(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    def upgrade(self) -> Upgraded: ...

    def status(self) -> StatusCode: ...

    def version(self) -> Version: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def content_length(self) -> int | None: ...

    def cookies(self) -> object: ...

    def url(self) -> Url: ...

    def remote_addr(self) -> SocketAddr | None: ...

    def extensions(self) -> Extensions: ...

    def extensions_mut(self) -> Extensions: ...

    def text(self) -> str: ...

    def text_with_charset(self, default_encoding: str) -> str: ...

    def json(self) -> T: ...

    def bytes(self) -> Bytes: ...

    def chunk(self) -> Bytes | None: ...

    def bytes_stream(self) -> object: ...

    def error_for_status(self) -> object: ...

    def error_for_status_ref(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_(r: object) -> "Response": ...

    @staticmethod
    def from_(r: Response) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    def status(self) -> StatusCode: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def cookies(self) -> object: ...

    def version(self) -> Version: ...

    def url(self) -> Url: ...

    def remote_addr(self) -> SocketAddr | None: ...

    def extensions(self) -> Extensions: ...

    def extensions_mut(self) -> Extensions: ...

    def content_length(self) -> int | None: ...

    def json(self) -> T: ...

    def bytes(self) -> Bytes: ...

    def text(self) -> str: ...

    def text_with_charset(self, default_encoding: str) -> str: ...

    def copy_to(self, w: W) -> int: ...

    def error_for_status(self) -> object: ...

    def error_for_status_ref(self) -> object: ...

    def read(self, buf: object) -> int: ...

    @staticmethod
    def from_(r: object) -> "Response": ...

class Form:
    """An async multipart/form-data request."""

    @staticmethod
    def default() -> "Form": ...

    @staticmethod
    def new() -> "Form": ...

    def text(self, name: T, value: U) -> Form: ...

    def part(self, name: T, part: Part) -> Form: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Form": ...

    @staticmethod
    def new() -> "Form": ...

    def boundary(self) -> str: ...

    def text(self, name: T, value: U) -> Form: ...

    def file(self, name: T, path: U) -> Form: ...

    def part(self, name: T, part: Part) -> Form: ...

    def percent_encode_path_segment(self) -> Form: ...

    def percent_encode_attr_chars(self) -> Form: ...

    def percent_encode_noop(self) -> Form: ...

    def into_stream(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Form": ...

    @staticmethod
    def new() -> "Form": ...

    def boundary(self) -> str: ...

    def text(self, name: T, value: U) -> Form: ...

    def file(self, name: T, path: U) -> Form: ...

    def part(self, name: T, part: Part) -> Form: ...

    def percent_encode_path_segment(self) -> Form: ...

    def percent_encode_attr_chars(self) -> Form: ...

    def percent_encode_noop(self) -> Form: ...

    def into_reader(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

class Part:
    """A field in a multipart form."""

    @staticmethod
    def text(value: T) -> "Part": ...

    @staticmethod
    def bytes(value: T) -> "Part": ...

    @staticmethod
    def stream(value: T) -> "Part": ...

    def mime_str(self, mime: str) -> Part: ...

    def file_name(self, filename: T) -> Part: ...

    def headers(self, headers: HeaderMap) -> Part: ...

    def fmt(self, f: Formatter) -> Result: ...

    def metadata(self) -> PartMetadata: ...

    @staticmethod
    def text(value: T) -> "Part": ...

    @staticmethod
    def bytes(value: T) -> "Part": ...

    @staticmethod
    def stream(value: T) -> "Part": ...

    @staticmethod
    def stream_with_length(value: T, length: int) -> "Part": ...

    @staticmethod
    def file(path: T) -> "Part": ...

    def mime_str(self, mime: str) -> Part: ...

    def file_name(self, filename: T) -> Part: ...

    def headers(self, headers: HeaderMap) -> Part: ...

    def fmt(self, f: Formatter) -> Result: ...

    def value_len(self) -> int | None: ...

    def metadata(self) -> PartMetadata: ...

    @staticmethod
    def text(value: T) -> "Part": ...

    @staticmethod
    def bytes(value: T) -> "Part": ...

    @staticmethod
    def reader(value: T) -> "Part": ...

    @staticmethod
    def reader_with_length(value: T, length: int) -> "Part": ...

    @staticmethod
    def file(path: T) -> "Part": ...

    def mime_str(self, mime: str) -> Part: ...

    def file_name(self, filename: T) -> Part: ...

    def headers(self, headers: HeaderMap) -> Part: ...

    def fmt(self, f: Formatter) -> Result: ...

    def value_len(self) -> int | None: ...

    def metadata(self) -> PartMetadata: ...

class Policy:
    """A type that controls the policy on how to handle the following of redirects.

The default value will catch redirect loops, and has a maximum of 10
redirects it will follow in a chain before returning an error.

- `limited` can be used have the same as the default behavior, but adjust
the allowed maximum redirect hops in a chain.
- `none` can be used to disable all redirect behavior.
- `custom` can be used to create a customized policy."""

    def retry(self, req: Req, result: object) -> Future | None: ...

    def clone_request(self, req: Req) -> Req | None: ...

    @staticmethod
    def limited(max: int) -> "Policy": ...

    @staticmethod
    def none() -> "Policy": ...

    @staticmethod
    def custom(policy: T) -> "Policy": ...

    def redirect(self, attempt: Attempt) -> Action: ...

    @staticmethod
    def default() -> "Policy": ...

    def fmt(self, f: Formatter) -> Result: ...

class Attempt:
    """A type that holds information on the next request and previous requests
in redirect chain."""

    def status(self) -> StatusCode: ...

    def url(self) -> Url: ...

    def previous(self) -> object: ...

    def follow(self) -> Action: ...

    def stop(self) -> Action: ...

    def error(self, error: E) -> Action: ...

class Action:
    """An action to perform when a redirect status code is found."""
    pass

class CertificateRevocationList:
    """Represents a X509 certificate revocation list."""

    @staticmethod
    def from_pem(pem: object) -> "CertificateRevocationList": ...

    @staticmethod
    def from_pem_bundle(pem_bundle: object) -> list[CertificateRevocationList]: ...

    def fmt(self, f: Formatter) -> Result: ...

class Certificate:
    """Represents a server X509 certificate."""

    @staticmethod
    def from_der(der: object) -> "Certificate": ...

    @staticmethod
    def from_pem(pem: object) -> "Certificate": ...

    @staticmethod
    def from_pem_bundle(pem_bundle: object) -> list[Certificate]: ...

    def fmt(self, f: Formatter) -> Result: ...

class Identity:
    """Represents a private key and X509 cert as a client certificate."""

    @staticmethod
    def from_pkcs12_der(der: object, password: str) -> "Identity": ...

    @staticmethod
    def from_pkcs8_pem(pem: object, key: object) -> "Identity": ...

    @staticmethod
    def from_pem(buf: object) -> "Identity": ...

    def fmt(self, f: Formatter) -> Result: ...

class Version:
    """A TLS protocol version."""
    pass

class TlsInfo:
    """Hyper extension carrying extra TLS layer information.
Made available to clients on responses when `tls_info` is set."""

    def peer_certificate(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

class Cookie:
    """A single HTTP cookie."""

    def name(self) -> str: ...

    def value(self) -> str: ...

    def http_only(self) -> bool: ...

    def secure(self) -> bool: ...

    def same_site_lax(self) -> bool: ...

    def same_site_strict(self) -> bool: ...

    def path(self) -> object: ...

    def domain(self) -> object: ...

    def max_age(self) -> Duration | None: ...

    def expires(self) -> SystemTime | None: ...

    def fmt(self, f: Formatter) -> Result: ...

class Jar:
    """A good default `CookieStore` implementation.

This is the implementation used when simply calling `cookie_store(true)`.
This type is exposed to allow creating one and filling it with some
existing cookies more easily, before creating a `Client`.

For more advanced scenarios, such as needing to serialize the store or
manipulate it between requests, you may refer to the
[reqwest_cookie_store crate](https://crates.io/crates/reqwest_cookie_store)."""

    def add_cookie_str(self, cookie: str, url: Url) -> None: ...

    def set_cookies(self, cookie_headers: object, url: Url) -> None: ...

    def cookies(self, url: Url) -> HeaderValue | None: ...

class CookieService:
    """A [`Service`] that adds cookie support to a lower-level [`Service`]."""

    @staticmethod
    def new(inner: S, cookie_store: object | None) -> "CookieService": ...

    def poll_ready(self, cx: Context) -> object: ...

    def call(self, req: object) -> Future: ...

class Error:
    """The Errors that may occur when processing a `Request`.

Note: Errors may include the full URL used to make the `Request`. If the URL
contains sensitive information (e.g. an API key as a query parameter), be
sure to remove it ([`without_url`](Error::without_url))"""

    def url(self) -> object: ...

    def url_mut(self) -> object: ...

    def with_url(self, url: Url) -> Self: ...

    def without_url(self) -> Self: ...

    def is_builder(self) -> bool: ...

    def is_redirect(self) -> bool: ...

    def is_status(self) -> bool: ...

    def is_timeout(self) -> bool: ...

    def is_request(self) -> bool: ...

    def is_connect(self) -> bool: ...

    def is_body(self) -> bool: ...

    def is_decode(self) -> bool: ...

    def status(self) -> StatusCode | None: ...

    def is_upgrade(self) -> bool: ...

    def fmt(self, f: Formatter) -> Result: ...

    def fmt(self, f: Formatter) -> Result: ...

    def source(self) -> object: ...

    @staticmethod
    def from_(err: Exception) -> Exception: ...

class Client:
    """A `Client` to make Requests with.

The Client has various configuration values to tweak, but the defaults
are set to what is usually the most commonly desired value. To configure a
`Client`, use `Client::builder()`.

The `Client` holds a connection pool internally, so it is advised that
you create one and **reuse** it.

# Examples

```rust
use reqwest::blocking::Client;
#
# fn run() -> Result<(), reqwest::Error> {
let client = Client::new();
let resp = client.get("http://httpbin.org/").send()?;
#   drop(resp);
#   Ok(())
# }

```"""

    @staticmethod
    def new() -> "Client": ...

    @staticmethod
    def builder() -> ClientBuilder: ...

    def get(self, url: U) -> RequestBuilder: ...

    def post(self, url: U) -> RequestBuilder: ...

    def put(self, url: U) -> RequestBuilder: ...

    def patch(self, url: U) -> RequestBuilder: ...

    def delete(self, url: U) -> RequestBuilder: ...

    def head(self, url: U) -> RequestBuilder: ...

    def request(self, method: Method, url: U) -> RequestBuilder: ...

    def execute(self, request: Request) -> object: ...

    @staticmethod
    def default() -> "Client": ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Client": ...

    @staticmethod
    def new() -> "Client": ...

    @staticmethod
    def builder() -> ClientBuilder: ...

    def get(self, url: U) -> RequestBuilder: ...

    def post(self, url: U) -> RequestBuilder: ...

    def put(self, url: U) -> RequestBuilder: ...

    def patch(self, url: U) -> RequestBuilder: ...

    def delete(self, url: U) -> RequestBuilder: ...

    def head(self, url: U) -> RequestBuilder: ...

    def request(self, method: Method, url: U) -> RequestBuilder: ...

    def execute(self, request: Request) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    def poll_ready(self, _cx: Context) -> object: ...

    def call(self, req: Request) -> Future: ...

    @staticmethod
    def default() -> "Client": ...

    @staticmethod
    def new() -> "Client": ...

    @staticmethod
    def builder() -> ClientBuilder: ...

    def get(self, url: U) -> RequestBuilder: ...

    def post(self, url: U) -> RequestBuilder: ...

    def put(self, url: U) -> RequestBuilder: ...

    def patch(self, url: U) -> RequestBuilder: ...

    def delete(self, url: U) -> RequestBuilder: ...

    def head(self, url: U) -> RequestBuilder: ...

    def request(self, method: Method, url: U) -> RequestBuilder: ...

    def execute(self, request: Request) -> Response: ...

    def fmt(self, f: Formatter) -> Result: ...

class ClientBuilder:
    """A `ClientBuilder` can be used to create a `Client` with  custom configuration.

# Example

```
# fn run() -> Result<(), reqwest::Error> {
use std::time::Duration;

let client = reqwest::blocking::Client::builder()
.timeout(Duration::from_secs(10))
.build()?;
# Ok(())
# }
```"""

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def new() -> "ClientBuilder": ...

    def build(self) -> Client: ...

    def user_agent(self, value: V) -> ClientBuilder: ...

    def default_headers(self, headers: HeaderMap) -> ClientBuilder: ...

    @staticmethod
    def default() -> "ClientBuilder": ...

    @staticmethod
    def default() -> "ClientBuilder": ...

    @staticmethod
    def new() -> "ClientBuilder": ...

    def build(self) -> Client: ...

    def user_agent(self, value: V) -> ClientBuilder: ...

    def default_headers(self, headers: HeaderMap) -> ClientBuilder: ...

    def cookie_store(self, enable: bool) -> ClientBuilder: ...

    def cookie_provider(self, cookie_store: object) -> ClientBuilder: ...

    def gzip(self, enable: bool) -> ClientBuilder: ...

    def brotli(self, enable: bool) -> ClientBuilder: ...

    def zstd(self, enable: bool) -> ClientBuilder: ...

    def deflate(self, enable: bool) -> ClientBuilder: ...

    def no_gzip(self) -> ClientBuilder: ...

    def no_brotli(self) -> ClientBuilder: ...

    def no_zstd(self) -> ClientBuilder: ...

    def no_deflate(self) -> ClientBuilder: ...

    def redirect(self, policy: Policy) -> ClientBuilder: ...

    def referer(self, enable: bool) -> ClientBuilder: ...

    def retry(self, policy: Builder) -> ClientBuilder: ...

    def proxy(self, proxy: Proxy) -> ClientBuilder: ...

    def no_proxy(self) -> ClientBuilder: ...

    def timeout(self, timeout: Duration) -> ClientBuilder: ...

    def read_timeout(self, timeout: Duration) -> ClientBuilder: ...

    def connect_timeout(self, timeout: Duration) -> ClientBuilder: ...

    def connection_verbose(self, verbose: bool) -> ClientBuilder: ...

    def pool_idle_timeout(self, val: D) -> ClientBuilder: ...

    def pool_max_idle_per_host(self, max: int) -> ClientBuilder: ...

    def http1_title_case_headers(self) -> ClientBuilder: ...

    def http1_allow_obsolete_multiline_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_ignore_invalid_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_allow_spaces_after_header_name_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_only(self) -> ClientBuilder: ...

    def http09_responses(self) -> ClientBuilder: ...

    def http2_prior_knowledge(self) -> ClientBuilder: ...

    def http3_prior_knowledge(self) -> ClientBuilder: ...

    def http2_initial_stream_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_initial_connection_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_adaptive_window(self, enabled: bool) -> ClientBuilder: ...

    def http2_max_frame_size(self, sz: object) -> ClientBuilder: ...

    def http2_max_header_list_size(self, max_header_size_bytes: int) -> ClientBuilder: ...

    def http2_keep_alive_interval(self, interval: object) -> ClientBuilder: ...

    def http2_keep_alive_timeout(self, timeout: Duration) -> ClientBuilder: ...

    def http2_keep_alive_while_idle(self, enabled: bool) -> ClientBuilder: ...

    def tcp_nodelay(self, enabled: bool) -> ClientBuilder: ...

    def local_address(self, addr: T) -> ClientBuilder: ...

    def interface(self, interface: str) -> ClientBuilder: ...

    def tcp_keepalive(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_interval(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_retries(self, retries: C) -> ClientBuilder: ...

    def tcp_user_timeout(self, val: D) -> ClientBuilder: ...

    def unix_socket(self, path: object) -> ClientBuilder: ...

    def windows_named_pipe(self, pipe: object) -> ClientBuilder: ...

    def tls_certs_merge(self, certs: object) -> ClientBuilder: ...

    def tls_certs_only(self, certs: object) -> ClientBuilder: ...

    def add_root_certificate(self, cert: Certificate) -> ClientBuilder: ...

    def tls_crls_only(self, crls: object) -> ClientBuilder: ...

    def add_crl(self, crl: CertificateRevocationList) -> ClientBuilder: ...

    def add_crls(self, crls: object) -> ClientBuilder: ...

    def identity(self, identity: Identity) -> ClientBuilder: ...

    def tls_danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def tls_danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def tls_sni(self, tls_sni: bool) -> ClientBuilder: ...

    def tls_version_min(self, version: Version) -> ClientBuilder: ...

    def min_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_version_max(self, version: Version) -> ClientBuilder: ...

    def max_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_backend_native(self) -> ClientBuilder: ...

    def use_native_tls(self) -> ClientBuilder: ...

    def tls_backend_rustls(self) -> ClientBuilder: ...

    def use_rustls_tls(self) -> ClientBuilder: ...

    def tls_backend_preconfigured(self, tls: object) -> ClientBuilder: ...

    def use_preconfigured_tls(self, tls: object) -> ClientBuilder: ...

    def tls_info(self, tls_info: bool) -> ClientBuilder: ...

    def https_only(self, enabled: bool) -> ClientBuilder: ...

    def hickory_dns(self, enable: bool) -> ClientBuilder: ...

    def no_hickory_dns(self) -> ClientBuilder: ...

    def resolve(self, domain: str, addr: SocketAddr) -> ClientBuilder: ...

    def resolve_to_addrs(self, domain: str, addrs: object) -> ClientBuilder: ...

    def dns_resolver(self, resolver: R) -> ClientBuilder: ...

    def tls_early_data(self, enabled: bool) -> ClientBuilder: ...

    def http3_max_idle_timeout(self, value: Duration) -> ClientBuilder: ...

    def http3_stream_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_conn_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_send_window(self, value: int) -> ClientBuilder: ...

    def http3_congestion_bbr(self) -> ClientBuilder: ...

    def http3_max_field_section_size(self, value: int) -> ClientBuilder: ...

    def http3_send_grease(self, enabled: bool) -> ClientBuilder: ...

    def connector_layer(self, layer: L) -> ClientBuilder: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "ClientBuilder": ...

    @staticmethod
    def new() -> "ClientBuilder": ...

    def build(self) -> Client: ...

    def user_agent(self, value: V) -> ClientBuilder: ...

    def default_headers(self, headers: HeaderMap) -> ClientBuilder: ...

    def cookie_store(self, enable: bool) -> ClientBuilder: ...

    def cookie_provider(self, cookie_store: object) -> ClientBuilder: ...

    def gzip(self, enable: bool) -> ClientBuilder: ...

    def brotli(self, enable: bool) -> ClientBuilder: ...

    def zstd(self, enable: bool) -> ClientBuilder: ...

    def deflate(self, enable: bool) -> ClientBuilder: ...

    def no_gzip(self) -> ClientBuilder: ...

    def no_brotli(self) -> ClientBuilder: ...

    def no_zstd(self) -> ClientBuilder: ...

    def no_deflate(self) -> ClientBuilder: ...

    def redirect(self, policy: Policy) -> ClientBuilder: ...

    def retry(self, policy: Builder) -> ClientBuilder: ...

    def referer(self, enable: bool) -> ClientBuilder: ...

    def proxy(self, proxy: Proxy) -> ClientBuilder: ...

    def no_proxy(self) -> ClientBuilder: ...

    def timeout(self, timeout: T) -> ClientBuilder: ...

    def connect_timeout(self, timeout: T) -> ClientBuilder: ...

    def connection_verbose(self, verbose: bool) -> ClientBuilder: ...

    def pool_idle_timeout(self, val: D) -> ClientBuilder: ...

    def pool_max_idle_per_host(self, max: int) -> ClientBuilder: ...

    def http1_title_case_headers(self) -> ClientBuilder: ...

    def http1_allow_obsolete_multiline_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_ignore_invalid_headers_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_allow_spaces_after_header_name_in_responses(self, value: bool) -> ClientBuilder: ...

    def http1_only(self) -> ClientBuilder: ...

    def http09_responses(self) -> ClientBuilder: ...

    def http2_prior_knowledge(self) -> ClientBuilder: ...

    def http2_initial_stream_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_initial_connection_window_size(self, sz: object) -> ClientBuilder: ...

    def http2_adaptive_window(self, enabled: bool) -> ClientBuilder: ...

    def http2_max_frame_size(self, sz: object) -> ClientBuilder: ...

    def http2_max_header_list_size(self, max_header_size_bytes: int) -> ClientBuilder: ...

    def http3_prior_knowledge(self) -> ClientBuilder: ...

    def http3_max_idle_timeout(self, value: Duration) -> ClientBuilder: ...

    def http3_stream_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_conn_receive_window(self, value: int) -> ClientBuilder: ...

    def http3_send_window(self, value: int) -> ClientBuilder: ...

    def http3_congestion_bbr(self) -> ClientBuilder: ...

    def http3_max_field_section_size(self, value: int) -> ClientBuilder: ...

    def http3_send_grease(self, enabled: bool) -> ClientBuilder: ...

    def tcp_nodelay(self, enabled: bool) -> ClientBuilder: ...

    def local_address(self, addr: T) -> ClientBuilder: ...

    def interface(self, interface: str) -> ClientBuilder: ...

    def tcp_keepalive(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_interval(self, val: D) -> ClientBuilder: ...

    def tcp_keepalive_retries(self, retries: C) -> ClientBuilder: ...

    def tcp_user_timeout(self, val: D) -> ClientBuilder: ...

    def unix_socket(self, path: object) -> ClientBuilder: ...

    def tls_certs_merge(self, certs: object) -> ClientBuilder: ...

    def tls_certs_only(self, certs: object) -> ClientBuilder: ...

    def add_root_certificate(self, cert: Certificate) -> ClientBuilder: ...

    def tls_crls_only(self, crls: object) -> ClientBuilder: ...

    def add_crl(self, crl: CertificateRevocationList) -> ClientBuilder: ...

    def add_crls(self, crls: object) -> ClientBuilder: ...

    def identity(self, identity: Identity) -> ClientBuilder: ...

    def tls_danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder: ...

    def tls_danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder: ...

    def tls_sni(self, tls_sni: bool) -> ClientBuilder: ...

    def tls_version_min(self, version: Version) -> ClientBuilder: ...

    def min_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_version_max(self, version: Version) -> ClientBuilder: ...

    def max_tls_version(self, version: Version) -> ClientBuilder: ...

    def tls_backend_native(self) -> ClientBuilder: ...

    def use_native_tls(self) -> ClientBuilder: ...

    def tls_backend_rustls(self) -> ClientBuilder: ...

    def use_rustls_tls(self) -> ClientBuilder: ...

    def tls_info(self, tls_info: bool) -> ClientBuilder: ...

    def tls_backend_preconfigured(self, tls: object) -> ClientBuilder: ...

    def use_preconfigured_tls(self, tls: object) -> ClientBuilder: ...

    def hickory_dns(self, enable: bool) -> ClientBuilder: ...

    def no_hickory_dns(self) -> ClientBuilder: ...

    def https_only(self, enabled: bool) -> ClientBuilder: ...

    def resolve(self, domain: str, addr: SocketAddr) -> ClientBuilder: ...

    def resolve_to_addrs(self, domain: str, addrs: object) -> ClientBuilder: ...

    def dns_resolver(self, resolver: object) -> ClientBuilder: ...

    def connector_layer(self, layer: L) -> ClientBuilder: ...

    @staticmethod
    def from_(builder: object) -> "ClientBuilder": ...

    def fmt(self, f: Formatter) -> Result: ...

class Body:
    """The body of a `Request`.

In most cases, this is not needed directly, as the
[`RequestBuilder.body`][builder] method uses `Into<Body>`, which allows
passing many things (like a string or vector of bytes).

[builder]: ./struct.RequestBuilder.html#method.body"""

    def as_bytes(self) -> object: ...

    @staticmethod
    def from_(bytes: Bytes) -> "Body": ...

    @staticmethod
    def from_(vec: list[int]) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(s: str) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Body": ...

    def as_bytes(self) -> object: ...

    @staticmethod
    def wrap_stream(stream: S) -> "Body": ...

    @staticmethod
    def wrap(inner: B) -> "Body": ...

    @staticmethod
    def default() -> "Body": ...

    @staticmethod
    def from_(bytes: Bytes) -> "Body": ...

    @staticmethod
    def from_(vec: list[int]) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(s: str) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(file: File) -> "Body": ...

    def fmt(self, f: Formatter) -> Result: ...

    def poll_frame(self, cx: Context) -> object: ...

    def size_hint(self) -> SizeHint: ...

    def is_end_stream(self) -> bool: ...

    @staticmethod
    def from_(r: Response) -> "Body": ...

    @staticmethod
    def new(reader: R) -> "Body": ...

    @staticmethod
    def sized(reader: R, len: int) -> "Body": ...

    def as_bytes(self) -> object: ...

    def buffer(self) -> object: ...

    @staticmethod
    def from_(v: list[int]) -> "Body": ...

    @staticmethod
    def from_(s: str) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(s: object) -> "Body": ...

    @staticmethod
    def from_(f: File) -> "Body": ...

    @staticmethod
    def from_(b: Bytes) -> "Body": ...

class Request:
    """A request which can be executed with `Client::execute()`."""

    @staticmethod
    def new(method: Method, url: Url) -> "Request": ...

    def method(self) -> Method: ...

    def method_mut(self) -> Method: ...

    def url(self) -> Url: ...

    def url_mut(self) -> Url: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def body(self) -> object: ...

    def body_mut(self) -> Body | None: ...

    def timeout(self) -> object: ...

    def timeout_mut(self) -> Duration | None: ...

    def try_clone(self) -> Request | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def try_from(req: object) -> object: ...

    @staticmethod
    def new(method: Method, url: Url) -> "Request": ...

    def method(self) -> Method: ...

    def method_mut(self) -> Method: ...

    def url(self) -> Url: ...

    def url_mut(self) -> Url: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def body(self) -> object: ...

    def body_mut(self) -> Body | None: ...

    def timeout(self) -> object: ...

    def timeout_mut(self) -> Duration | None: ...

    def version(self) -> Version: ...

    def version_mut(self) -> Version: ...

    def try_clone(self) -> Request | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def try_from(req: object) -> object: ...

    @staticmethod
    def new(method: Method, url: Url) -> "Request": ...

    def method(self) -> Method: ...

    def method_mut(self) -> Method: ...

    def url(self) -> Url: ...

    def url_mut(self) -> Url: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def version(self) -> Version: ...

    def version_mut(self) -> Version: ...

    def body(self) -> object: ...

    def body_mut(self) -> Body | None: ...

    def timeout(self) -> object: ...

    def timeout_mut(self) -> Duration | None: ...

    def try_clone(self) -> Request | None: ...

    @staticmethod
    def try_from(req: object) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

class RequestBuilder:
    """A builder to construct the properties of a `Request`.

To construct a `RequestBuilder`, refer to the `Client` documentation."""

    @staticmethod
    def from_parts(client: Client, request: Request) -> "RequestBuilder": ...

    def query(self, query: T) -> RequestBuilder: ...

    def form(self, form: T) -> RequestBuilder: ...

    def json(self, json: T) -> RequestBuilder: ...

    def basic_auth(self, username: U, password: P | None) -> RequestBuilder: ...

    def bearer_auth(self, token: T) -> RequestBuilder: ...

    def body(self, body: T) -> RequestBuilder: ...

    def timeout(self, timeout: Duration) -> RequestBuilder: ...

    def multipart(self, multipart: Form) -> RequestBuilder: ...

    def header(self, key: K, value: V) -> RequestBuilder: ...

    def headers(self, headers: HeaderMap) -> RequestBuilder: ...

    def fetch_mode_no_cors(self) -> RequestBuilder: ...

    def fetch_credentials_same_origin(self) -> RequestBuilder: ...

    def fetch_credentials_include(self) -> RequestBuilder: ...

    def fetch_credentials_omit(self) -> RequestBuilder: ...

    def fetch_cache_default(self) -> RequestBuilder: ...

    def fetch_cache_no_store(self) -> RequestBuilder: ...

    def fetch_cache_reload(self) -> RequestBuilder: ...

    def fetch_cache_no_cache(self) -> RequestBuilder: ...

    def fetch_cache_force_cache(self) -> RequestBuilder: ...

    def fetch_cache_only_if_cached(self) -> RequestBuilder: ...

    def build(self) -> Request: ...

    def build_split(self) -> object: ...

    def send(self) -> Response: ...

    def try_clone(self) -> RequestBuilder | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_parts(client: Client, request: Request) -> "RequestBuilder": ...

    def header(self, key: K, value: V) -> RequestBuilder: ...

    def headers(self, headers: HeaderMap) -> RequestBuilder: ...

    def basic_auth(self, username: U, password: P | None) -> RequestBuilder: ...

    def bearer_auth(self, token: T) -> RequestBuilder: ...

    def body(self, body: T) -> RequestBuilder: ...

    def timeout(self, timeout: Duration) -> RequestBuilder: ...

    def multipart(self, multipart: Form) -> RequestBuilder: ...

    def query(self, query: T) -> RequestBuilder: ...

    def version(self, version: Version) -> RequestBuilder: ...

    def form(self, form: T) -> RequestBuilder: ...

    def json(self, json: T) -> RequestBuilder: ...

    def build(self) -> Request: ...

    def build_split(self) -> object: ...

    def send(self) -> object: ...

    def try_clone(self) -> RequestBuilder | None: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_parts(client: Client, request: Request) -> "RequestBuilder": ...

    def header(self, key: K, value: V) -> RequestBuilder: ...

    def headers(self, headers: HeaderMap) -> RequestBuilder: ...

    def basic_auth(self, username: U, password: P | None) -> RequestBuilder: ...

    def bearer_auth(self, token: T) -> RequestBuilder: ...

    def body(self, body: T) -> RequestBuilder: ...

    def timeout(self, timeout: Duration) -> RequestBuilder: ...

    def query(self, query: T) -> RequestBuilder: ...

    def version(self, version: Version) -> RequestBuilder: ...

    def form(self, form: T) -> RequestBuilder: ...

    def json(self, json: T) -> RequestBuilder: ...

    def multipart(self, multipart: Form) -> RequestBuilder: ...

    def build(self) -> Request: ...

    def build_split(self) -> object: ...

    def send(self) -> Response: ...

    def try_clone(self) -> RequestBuilder | None: ...

class Response:
    """A Response to a submitted `Request`."""

    def status(self) -> StatusCode: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def content_length(self) -> int | None: ...

    def url(self) -> Url: ...

    def json(self) -> T: ...

    def text(self) -> str: ...

    def bytes(self) -> Bytes: ...

    def bytes_stream(self) -> object: ...

    def error_for_status(self) -> object: ...

    def error_for_status_ref(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    def upgrade(self) -> Upgraded: ...

    def status(self) -> StatusCode: ...

    def version(self) -> Version: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def content_length(self) -> int | None: ...

    def cookies(self) -> object: ...

    def url(self) -> Url: ...

    def remote_addr(self) -> SocketAddr | None: ...

    def extensions(self) -> Extensions: ...

    def extensions_mut(self) -> Extensions: ...

    def text(self) -> str: ...

    def text_with_charset(self, default_encoding: str) -> str: ...

    def json(self) -> T: ...

    def bytes(self) -> Bytes: ...

    def chunk(self) -> Bytes | None: ...

    def bytes_stream(self) -> object: ...

    def error_for_status(self) -> object: ...

    def error_for_status_ref(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def from_(r: object) -> "Response": ...

    @staticmethod
    def from_(r: Response) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    def status(self) -> StatusCode: ...

    def headers(self) -> HeaderMap: ...

    def headers_mut(self) -> HeaderMap: ...

    def cookies(self) -> object: ...

    def version(self) -> Version: ...

    def url(self) -> Url: ...

    def remote_addr(self) -> SocketAddr | None: ...

    def extensions(self) -> Extensions: ...

    def extensions_mut(self) -> Extensions: ...

    def content_length(self) -> int | None: ...

    def json(self) -> T: ...

    def bytes(self) -> Bytes: ...

    def text(self) -> str: ...

    def text_with_charset(self, default_encoding: str) -> str: ...

    def copy_to(self, w: W) -> int: ...

    def error_for_status(self) -> object: ...

    def error_for_status_ref(self) -> object: ...

    def read(self, buf: object) -> int: ...

    @staticmethod
    def from_(r: object) -> "Response": ...

class Form:
    """A multipart/form-data request."""

    @staticmethod
    def default() -> "Form": ...

    @staticmethod
    def new() -> "Form": ...

    def text(self, name: T, value: U) -> Form: ...

    def part(self, name: T, part: Part) -> Form: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Form": ...

    @staticmethod
    def new() -> "Form": ...

    def boundary(self) -> str: ...

    def text(self, name: T, value: U) -> Form: ...

    def file(self, name: T, path: U) -> Form: ...

    def part(self, name: T, part: Part) -> Form: ...

    def percent_encode_path_segment(self) -> Form: ...

    def percent_encode_attr_chars(self) -> Form: ...

    def percent_encode_noop(self) -> Form: ...

    def into_stream(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

    @staticmethod
    def default() -> "Form": ...

    @staticmethod
    def new() -> "Form": ...

    def boundary(self) -> str: ...

    def text(self, name: T, value: U) -> Form: ...

    def file(self, name: T, path: U) -> Form: ...

    def part(self, name: T, part: Part) -> Form: ...

    def percent_encode_path_segment(self) -> Form: ...

    def percent_encode_attr_chars(self) -> Form: ...

    def percent_encode_noop(self) -> Form: ...

    def into_reader(self) -> object: ...

    def fmt(self, f: Formatter) -> Result: ...

class Part:
    """A field in a multipart form."""

    @staticmethod
    def text(value: T) -> "Part": ...

    @staticmethod
    def bytes(value: T) -> "Part": ...

    @staticmethod
    def stream(value: T) -> "Part": ...

    def mime_str(self, mime: str) -> Part: ...

    def file_name(self, filename: T) -> Part: ...

    def headers(self, headers: HeaderMap) -> Part: ...

    def fmt(self, f: Formatter) -> Result: ...

    def metadata(self) -> PartMetadata: ...

    @staticmethod
    def text(value: T) -> "Part": ...

    @staticmethod
    def bytes(value: T) -> "Part": ...

    @staticmethod
    def stream(value: T) -> "Part": ...

    @staticmethod
    def stream_with_length(value: T, length: int) -> "Part": ...

    @staticmethod
    def file(path: T) -> "Part": ...

    def mime_str(self, mime: str) -> Part: ...

    def file_name(self, filename: T) -> Part: ...

    def headers(self, headers: HeaderMap) -> Part: ...

    def fmt(self, f: Formatter) -> Result: ...

    def value_len(self) -> int | None: ...

    def metadata(self) -> PartMetadata: ...

    @staticmethod
    def text(value: T) -> "Part": ...

    @staticmethod
    def bytes(value: T) -> "Part": ...

    @staticmethod
    def reader(value: T) -> "Part": ...

    @staticmethod
    def reader_with_length(value: T, length: int) -> "Part": ...

    @staticmethod
    def file(path: T) -> "Part": ...

    def mime_str(self, mime: str) -> Part: ...

    def file_name(self, filename: T) -> Part: ...

    def headers(self, headers: HeaderMap) -> Part: ...

    def fmt(self, f: Formatter) -> Result: ...

    def value_len(self) -> int | None: ...

    def metadata(self) -> PartMetadata: ...

class Action:
    Success: "Action"
    Retryable: "Action"

class Connecting:
    InProgress: "Connecting"
    Acquired: "Connecting"

"""Create a retry builder with a request scope.

To provide a scope that isn't a closure, use the more general
[`Builder::scoped()`]."""
def for_host(host: S) -> Builder: ...

"""Create a retry policy that will never retry any request.

This is useful for disabling the `Client`s default behavior of retrying
protocol nacks."""
def never() -> Builder: ...

def basic_auth(username: U, password: P | None) -> HeaderValue: ...

"""Shortcut method to quickly make a `GET` request.

See also the methods on the [`reqwest::Response`](./struct.Response.html)
type.

**NOTE**: This function creates a new internal `Client` on each call,
and so should not be used if making many requests. Create a
[`Client`](./struct.Client.html) instead.

# Examples

```rust
# async fn run() -> Result<(), reqwest::Error> {
let body = reqwest::get("https://www.rust-lang.org").await?
.text().await?;
# Ok(())
# }
```

# Errors

This function fails if:

- native TLS backend cannot be initialized
- supplied `Url` cannot be parsed
- there was an error while sending request
- redirect limit was exhausted"""
async def get(url: T) -> Response: ...

"""Shortcut method to quickly make a *blocking* `GET` request.

**NOTE**: This function creates a new internal `Client` on each call,
and so should not be used if making many requests. Create a
[`Client`](./struct.Client.html) instead.

# Examples

```rust
# fn run() -> Result<(), reqwest::Error> {
let body = reqwest::blocking::get("https://www.rust-lang.org")?
.text()?;
# Ok(())
# }
# fn main() { }
```

# Errors

This function fails if:

- the native TLS backend cannot be initialized,
- the supplied `Url` cannot be parsed,
- there was an error while sending request,
- a redirect loop was detected,
- the redirect limit was exhausted, or
- the total download time exceeds 30 seconds."""
def get(url: T) -> Response: ...

__all__: list[str] = ["for_host", "never", "basic_auth", "get", "get", "Result", "Builder", "ScopeFn", "ClassifyFn", "ReqRep", "Unnameable", "Internal", "Internal", "Client", "ClientBuilder", "Body", "Request", "RequestBuilder", "Response", "Form", "Part", "GaiResolver", "Name", "InvalidNameError", "Proxy", "NoProxy", "Pool", "ConnectingLock", "ConnectingWaiter", "PoolClient", "PoolConnection", "Client", "ClientBuilder", "Body", "Upgraded", "Request", "RequestBuilder", "Response", "Form", "Part", "Policy", "Attempt", "Action", "CertificateRevocationList", "Certificate", "Identity", "Version", "TlsInfo", "Cookie", "Jar", "CookieService", "Error", "Client", "ClientBuilder", "Body", "Request", "RequestBuilder", "Response", "Form", "Part", "Action", "Connecting"]
